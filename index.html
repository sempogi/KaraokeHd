<!--
KARAOKE HD ‚Äî WebAudio Engine + Custom MIDI Parser
Copyright ¬© 2026 Sem Sabiduria. All rights reserved.

MIT License (with Non-Commercial Rider)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, subject to the following conditions:

1. The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.

2. Non-Commercial Rider:
   - The Software may NOT be used for commercial purposes without prior written
     permission from the copyright holder.
   - Commercial purposes include, but are not limited to: selling, licensing,
     SaaS offerings, paid apps, or bundling in products/services for sale.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="KaraokeHD ‚Äî standalone browser karaoke player with WebAudio-based synth, MIDI/KAR parser, lyrics and video backgrounds." />
  <meta name="theme-color" content="#0f1420" />
  <link rel="icon" href="/favicon.ico" />
  <!-- Basic CSP: allows inline scripts/styles because this is a single-file app. Harden for production. -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' data:; media-src 'self' blob:; connect-src 'self' blob:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline';">
<title>KaraokeHD</title>

<style>
/* =========================
   LAYERS ORDER
   base < components < karaoke < modes
   ========================= */
@layer base, components, karaoke, modes;

/* =========================
   BASE (tokens + global)
   ========================= */
@layer base {
  :root {
    --karaokeFont: system-ui, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial, sans-serif;

    --bg: #0f1420;
    --fg: #e6edf6;
    --muted: #9fbad1;
    --accent: #00b3ff;
    --border: #24344e;
    --card: #0c1625;
    --green: #17c964;
    --amber: #f5a524;
    --pink: #f31260;
    --red: #f31260;

    --stripW: 60px;
    --gap: 6px;
    --meterH: 72px;
    --meterW: 6px;
    --fontBase: 10px;
    --fontTiny: 9px;
    --radius: 8px;
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    background: var(--bg);
    color: var(--fg);
    font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif;
  }

  header {
    padding: 8px 10px;
    border-bottom: 1px solid var(--border);
    background: #0c111b;
    position: relative;
    z-index: 1;
  }

  h1 { margin: 0; font-size: 14px; }

  #top {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    align-items: center;
    padding: 8px;
    border-bottom: 1px solid var(--border);
    background: #0c111b;
    position: sticky;
    top: 0;
    z-index: 1000;
  }

  label { font-size: 10px; color: #a7c4de; }

  select, input[type=range] {
    background: #122136;
    color: #e6edf6;
    border: 1px solid #2a3a55;
    border-radius: 6px;
  }

  /* Density presets */
  .density-ultra {
    --stripW: 60px; --meterH: 72px; --meterW: 6px; --gap: 6px;
    --fontBase: 10px; --fontTiny: 9px; --radius: 8px;
  }
  .density-compact {
    --stripW: 72px; --meterH: 84px; --meterW: 7px; --gap: 7px;
    --fontBase: 11px; --fontTiny: 10px;
  }
  .density-normal {
    --stripW: 96px; --meterH: 108px; --meterW: 8px; --gap: 8px;
    --fontBase: 12px; --fontTiny: 11px;
  }
}

/* =========================
   COMPONENTS (buttons, chips, grids, meters)
   ========================= */
@layer components {
  .btn {
    background: #122136;
    border: 1px solid #2a3a55;
    color: #e6edf6;
    padding: 7px 10px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 11px;
  }
  .btn.primary {
    background: var(--accent);
    color: #001019;
    border-color: #0ea5d3;
    font-weight: 600;
  }
  .btn.danger {
    background: var(--red);
    border-color: #aa0c43;
  }
  .btn[disabled] { opacity: .5; cursor: not-allowed; }

  #vizWrap {
    border-bottom: 1px solid var(--border);
    background: linear-gradient(180deg, #0b1424, #0a1220);
  }
  #mainViz {
    display: block;
    width: 100%;
    height: 84px;
  }

  .floatWin {
    position: fixed;
    top: 120px;
    left: 16px;
    min-width: 260px;
    min-height: 120px;
    background: #0b1424;
    border: 1px solid #20324d;
    border-radius: 12px;
    box-shadow: 0 10px 32px rgba(0,0,0,.45);
    display: none;
    z-index: 10000;
    height: 72vh;
    overflow: auto;
  }
  .winHeader {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 8px;
    border-bottom: 1px solid #1f2c44;
    background: #0c111b;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    cursor: move;
    position: sticky;
    top: 0;
    z-index: 2;
  }
  .winHeader strong { font-size: 12px; }
  .winBtns { display: flex; gap: 6px; }
  .winBody { padding: 8px; }

  #chGridVert {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: var(--stripW);
    gap: var(--gap);
    overflow: auto;
    align-items: start;
  }

  .strip {
    background: #0b1424;
    border: 1px solid #20324d;
    border-radius: var(--radius);
    padding: 4px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .strip .title {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 2px;
    font-size: var(--fontBase);
  }
  .badge {
    background: #16263f;
    border: 1px solid #2a3a55;
    color: #a7c4de;
    padding: 0 4px;
    border-radius: 999px;
    font-size: var(--fontTiny);
    margin-left: 4px;
  }

  .vMeter {
    height: var(--meterH);
    width: var(--meterW);
    border: 1px solid #2a3a55;
    border-radius: 999px;
    background: #122136;
    margin: 4px 0;
    position: relative;
    overflow: hidden;
  }
  .vMeter .bar {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    background: linear-gradient(180deg, #17c964, #f5a524, var(--pink));
    height: 0%;
    width: 100%;
  }

  .controls {
    display: flex;
    flex-direction: column;
    gap: 4px;
    font-size: var(--fontTiny);
    align-items: center;
    width: 100%;
  }
  .row { display: flex; gap: 4px; align-items: center; }

  .chip {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    border: 1px solid #2a3a55;
    background: #10182a;
    color: #a7c4de;
    border-radius: 999px;
    padding: 2px 6px;
    font-size: 9px;
  }
  .ctlV {
    display: flex;
    flex-direction: column;
    gap: 3px;
    align-items: center;
  }
  .symSel { width: 100%; font-size: 10px; }

  .plItem {
    padding: 5px;
    border-bottom: 1px solid #22324b;
    cursor: pointer;
    font-size: 11px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 6px;
  }
  .plItem.active { background: #122136; }
  .plItem .btn { padding: 4px 8px; font-size: 10px; }

  pre.log {
    white-space: pre-wrap;
    margin: 0;
    color: #b6c9dc;
    font-size: 11px;
  }

  /* Rainbow gradient animation for 'Playing' title */
  .rainbow-text {
    background: linear-gradient(
      90deg,
      #ff0066 0%,
      #ff8a00 16%,
      #ffe600 33%,
      #33cc33 50%,
      #00a3ff 66%,
      #7a00ff 83%,
      #ff0066 100%
    );
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    animation: rainbowShift 6s linear infinite;
    font-weight: 700;
    background-size: 200% 200%;
    /* Optional: if you animate transform/opacity later, uncomment: */
    /* will-change: background-position; */
  }
  @keyframes rainbowShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }

  @media (prefers-reduced-motion: reduce) {
    .rainbow-text { animation: none; }
  }

  /* Range/Select mobile & coarse pointer consolidation */
  @media (max-width: 720px), (pointer: coarse) {
    .btn {
      padding: 10px 12px;
      font-size: 12px;
    }
    select, input[type=range] { font-size: 12px; }
  }

  @media (min-width: 1280px) {
    #mainViz { height: 120px; }
  }
}

/* =========================
   KARAOKE (lyrics, window, chroma-safe, countdown)
   ========================= */
@layer karaoke {
  /* Ensure font family applies to both current/next lines */
  #karoCurr, #karoNext {
    font-family: var(--karaokeFont);
  }

  #winKaro {
    --kara-fill: #f31260;  /* pink */
  --kara-base: #ffffff;  /* white */
  --kara-bg:   #00ff00;  /* green */
    --kara-weight: 800;
    --kara-letter-spacing: 0em;
    --kara-token-gap: 0.04em;
    --glow-radius: 10px;
    --glow-radius2: 14px;
    --kara-blend: normal;
    --kara-stroke-w: 1px;
    --kara-stroke-c: rgba(0,0,0,0.55);
    background: var(--kara-bg);
    border-color: transparent;
  }
  #winKaro .winHeader {
    background: var(--kara-bg);
    border-bottom-color: transparent;
  }
  #winKaro .winBody {
    background: var(--kara-bg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    padding-top: 30px; /* fixed top spacer so content starts below chips */
  }

  /* Current line: large, bold */
  #karoCurr {
    font-size: clamp(18px, 5.2vw, 34px);
    line-height: 1.30;
    font-weight: var(--kara-weight);
    margin: 12px 0 0; /* normalized */
    white-space: pre-wrap;
  }

  /* Next line: fully visible for chroma; size via --next-size */
  #karoNext {
    font-size: var(--next-size, clamp(14px, 3.2vw, 20px));
    margin: 10px 0 6px;
    white-space: pre-wrap;
    opacity: 1;
    color: var(--kara-base);
    text-shadow: none;
    filter: none;
    -webkit-text-stroke: 1px rgba(0,0,0,0.55);
    /* text-stroke (non-standard) kept for environments that support it */
    text-stroke: 0.5px rgba(0,0,0,0.55);
    mix-blend-mode: normal;
  }

  /* Alignment toggles */
  #winKaro.karo-align-left #karoCurr,
  #winKaro.karo-align-left #karoNext { text-align: left; }
  #winKaro.karo-align-center #karoCurr,
  #winKaro.karo-align-center #karoNext { text-align: center; }

  /* Token/character structure */
  .karoToken { display: inline-block; margin: 0 var(--kara-token-gap); }
  .karoChar {
    position: relative;
    display: inline-block;
    letter-spacing: var(--kara-letter-spacing);
  }
  .karoLetter.base {
    position: relative;
    color: var(--kara-base);
    text-shadow: 1px 2px 6px rgba(10,30,55,0.60);
  }
  .karoLetter.hi {
    position: absolute;
    left: 0; top: 0;
    color: var(--kara-fill);
    text-shadow: 0 0 var(--glow-radius) var(--kara-fill), 0 0 var(--glow-radius2) var(--kara-fill);
    clip-path: inset(0 calc(100% - var(--kara-progress, 0%)) 0 0);
    mix-blend-mode: var(--kara-blend);
  }

  /* Micro stroke mode */
  #winKaro.karo-micro-stroke .karoLetter.base,
  #winKaro.karo-micro-stroke .karoLetter.hi {
    -webkit-text-stroke: var(--kara-stroke-w) var(--kara-stroke-c);
    text-stroke: var(--kara-stroke-w) var(--kara-stroke-c);
  }

  /* Chroma-safe mode (no glow, normal blend, solid color) */
  #winKaro.karo-chroma-safe {
    --glow-radius: 0px;
    --glow-radius2: 0px;
    --kara-blend: normal;
    --kara-fill: #ffd84a;
  }
  #winKaro.karo-chroma-safe .karoLetter.base,
  #winKaro.karo-chroma-safe .karoLetter.hi {
    text-shadow: none !important;
    filter: none !important;
    -webkit-filter: none !important;
    mix-blend-mode: normal !important;
  }

  /* Fullscreen adjustments */
  #winKaro:fullscreen, #winKaro:-webkit-full-screen {
    background: var(--kara-bg) !important;
    width: 100vw !important;
    height: 100vh !important;
    top: 0 !important;
    left: 0 !important;
    border-radius: 0 !important;
  }

  /* Countdown ‚Äî chroma-safe styling */
  #karoStartBigDynamic {
    color: #ffd84a !important;
    text-shadow: none !important;
    filter: none !important;
    -webkit-filter: none !important;
    mix-blend-mode: normal !important;
    -webkit-text-stroke: 1px rgba(0,0,0,0.55);
    text-stroke: 1px rgba(0,0,0,0.55);
  }
  #karoStartBarsDynamic .karoStartSegDynamic {
    background: #ffd84a !important;
    box-shadow: none !important;
    outline: 1px solid rgba(0,0,0,0.55) !important;
    outline-offset: 0;
  }

  /* Karaoke tokens (legacy lyTok retained but simplified) */
  .lyTok { display: inline-block; margin: 0 .06em; }
  .lyTok.done { opacity: 0.92; }
  .lyTok.active { color: var(--accent); }

  /* Tiny color dots for Solf/Retune ‚Äî no text */
  #solfDetect, #tuneDetect {
    display: inline-block;
    width: 10px; height: 10px;
    border-radius: 999px;
    border: 1px solid #2a3a55;
    padding: 0;
    font-size: 0;
    line-height: 0;
  }

  /* Mobile window sizing */
  @media (max-width: 720px) {
    .floatWin {
      left: 8px !important;
      right: 8px !important;
      width: calc(100vw - 16px) !important;
      height: 72vh;
    }
    #winChannels { width: calc(100vw - 16px) !important; }
    #winKaro     { width: calc(100vw - 16px) !important; }
  }
}

/* =========================
   MODES (feature toggles)
   ========================= */
@layer modes {
  /* Audio-only: hide visual UIs */
  body.audio-only #vizWrap,
  body.audio-only .floatWin { display: none !important; }

  body.audio-only #top [aria-label="Mixer"],
  body.audio-only #top [aria-label="EQ"],
  body.audio-only #top [aria-label="Playlist"],
  body.audio-only #top [aria-label="Log"],
  body.audio-only #top [aria-label="Lyrics"],
  body.audio-only #top [aria-label="Karaoke"],
  body.audio-only #top [aria-label="Karaoke Settings"] {
    display: none !important;
  }

  body.audio-only #top { gap: 8px; }
}
</style>
¬†
<style>
/* === Do NOT touch #winKaro positioning; keep your centering/drag logic === */

/* Body manages text layout and video crop (video isn't inside .winBody) */
#winKaro .winBody {
  position: relative;
  overflow: hidden; /* OK for lyrics area; controls are anchored to window */
}

/* Only when video background is ON */
#winKaro.karoHasBg .winBody {
  background: transparent; /* reveal video; your static color shows when OFF */
}

/* === Full-window background video (anchors to #winKaro) === */
#winKaro .karoBgVideo {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  object-fit: cover;           /* fills w/o distortion; crops instead of bands */
  z-index: 0;
  pointer-events: none;        /* never blocks clicks */
  opacity: 1;
  transition: opacity 250ms ease;
}

/* Contrast overlay above video (covers whole window) */
#winKaro .karoOverlay {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.25);
  z-index: 1;
  pointer-events: none;
}

/* Header + lyrics above overlay/video */
#winKaro .winHeader { position: relative; z-index: 2; }
#winKaro #karoCurr,
#winKaro #karoNext {
  position: relative;
  z-index: 2;
  color: #fff;
  text-shadow: 0 2px 6px rgba(0,0,0,0.75);
  padding: 10px 12px;
  line-height: 1.4;
}
#winKaro #karoNext { opacity: 0.8; }

/* === Controls anchored to the whole window (avoid .winBody clipping) === */
#winKaro .karoPL {
  position: absolute;
  z-index: 4;                 /* above header/lyrics */
  left: 8px;
  right: 8px;
  bottom: 8px;                /* dock at bottom of the window */
  background: rgba(0,0,0,0.35);
  color: #fff;
  padding: 8px;
  border-radius: 6px;
  font-size: 11px;
}
#winKaro .karoPL.hidden { display: none !important; }

#winKaro .karoPLRow {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  align-items: center;
}

#winKaro .karoPLList {
  margin: 6px 0 0 0;
  padding-left: 18px;
  /* Adaptive height so the list doesn't feel ‚Äúclipped‚Äù */
  max-height: min(40vh, 320px);
  overflow: auto;
}
#winKaro:fullscreen .karoPLList,
#winKaro:-webkit-full-screen .karoPLList {
  max-height: min(60vh, 480px);
}

#winKaro .karoPLList li {
  display: flex;
  gap: 8px;
  align-items: center;
  margin: 2px 0;
}
#winKaro .karoPLList .idx { width: 1.5em; text-align: right; opacity: 0.7; }
#winKaro .karoPLList .name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#winKaro .karoPLList .dur { opacity: 0.7; }
#winKaro .karoPLList .now { color: #0ff; }

#winKaro .karoPLStatus { margin-top: 6px; opacity: 0.85; }

/* === Simple in-window settings button (top-right) === */
#winKaro .karoSimpleBtn {
  position: absolute;
  z-index: 4;
  top: 8px;
  right: 8px;
  width: 30px;
  height: 30px;
  border-radius: 999px;
  border: none;
  background: rgba(0,0,0,0.6);
  color: #fff;
  font-size: 16px;
  line-height: 30px;
  text-align: center;
  cursor: pointer;
  user-select: none;
}
#winKaro .karoSimpleBtn:hover { background: rgba(0,0,0,0.75); }
#winKaro .karoSimpleBtn:active { transform: scale(0.98); }

/* Mini settings panel (auto-hide) */
#winKaro .karoMiniPanel {
  position: absolute;
  z-index: 4;
  top: 46px;                   /* just below the button */
  right: 8px;
  background: rgba(0,0,0,0.65);
  color: #fff;
  padding: 8px 10px;
  border-radius: 8px;
  font-size: 12px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.35);
  display: none;
}
#winKaro .karoMiniPanel .row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin: 4px 0;
}

/* Safety: hide any native media controls */
#winKaro .karoBgVideo::-webkit-media-controls { display: none !important; }
#winKaro .karoBgVideo::-moz-media-controls { display: none !important; }

/* === Fullscreen handling (use ‚õ∂ on #winKaro) === */
#winKaro:fullscreen,
#winKaro:-webkit-full-screen {
  width: 100vw !important;
  height: 100vh !important;
  max-width: 100vw !important;
  max-height: 100vh !important;
  left: 0 !important;
  top: 0 !important;
  margin: 0 !important;
  transform: none !important;  /* avoid double centering in fullscreen */
}
/* Video stays at the very back */
#winKaro .karoBgVideo {
  z-index: 0 !important;
}

/* Overlay slightly above video */
#winKaro .karoOverlay {
  z-index: 1 !important;
}

/* Lyrics and countdown above everything */
#winKaro .winHeader,
#winKaro #karoCurr,
#winKaro #karoNext,
#karoStartRowDynamic { /* your big countdown row */
  z-index: 2 !important;
  position: relative; /* ensure stacking context */
}
</style>

</head>
<body class="density-ultra">

<header style="text-align:left; padding:8px 10px;">
<h1 style="margin:0; font-size:30px; line-height:1.2;">
<strong style="
color:#f31260;
font-weight:900;
font-size:40px;
text-shadow: 0 0 12px rgba(243,18,96,0.8), 0 0 24px rgba(243,18,96,0.6);
">
KaraokeHD
</strong>
<span style="color:#9fbad1; font-size:20px;"> ‚Äî </span>
<strong style="color:#39FF14; font-weight:900;">codex45</strong>
<span style="color:#9fbad1; font-size:18px;"> (v5.4b.1‚Äëperf)</span>
</h1>

<small id="hdrTagline" style="display:block; margin-top:6px; color:#9fbad1; font-size:10px;">
Ultra‚ÄëCompact Mixer ‚Ä¢ Visualizer ‚Ä¢ Recording ‚Ä¢ Retune ‚Ä¢ Lyrics ‚Ä¢ Karaoke
</small>

<div id="nowPlaying" style="margin-top:10px; font-size:18px; font-weight:700;">
<span style="color:#9fbad1;">Playing:</span>
<span id="currentTitle" class="rainbow-text">(No track loaded)</span>
</div>
</header>

<div id="vizWrap">
<canvas id="mainViz" aria-label="Wave Visualizer"></canvas>
</div>

<div id="top">
<input id="midFiles" type="file" multiple accept=".mid,.kar" />
<button id="btnInit" class="btn primary">Init</button>
<button id="btnPlay" class="btn" disabled aria-label="Play">‚ñ∂</button>
<button id="btnStop" class="btn" disabled aria-label="Stop">‚èπ</button>
<button id="btnPanic" class="btn danger" disabled aria-label="Panic">‚õë</button>

<label>Assign
<select id="autoAssign"><option value="1" selected>On</option><option value="0">Off</option></select>
</label>
<label>Recovery
<select id="autoRecovery"><option value="1" selected>On</option><option value="0">Off</option></select>
</label>
<label>Palette
<select id="palette"><option value="classic" selected>Classic</option><option value="edm">EDM</option><option value="chip">Chip</option></select>
</label>
<label>Preset
<select id="preset"><option value="Flat" selected>Flat</option><option value="Warm">Warm</option><option value="Bright">Bright</option><option value="Vocal">Vocal</option><option value="BassBoost">Bass+</option><option value="BassStrong">Bass++</option></select>
</label>
<label>Soft Synth <input id="softSynth" type="checkbox" /></label>
<label>Anti‚ÄëBeep <input id="antiBeep" type="checkbox" checked /></label>
<label>Lim <input id="limStr" type="range" min="0.50" max="0.95" value="0.78" step="0.01" /></label>
<label>Notch <select id="notch"><option value="0">Off</option><option value="50">50</option><option value="60" selected>60</option></select></label>

<label>Density
<select id="density"><option value="ultra" selected>Ultra</option><option value="compact">Compact</option><option value="normal">Normal</option></select>
</label>
<label>Fit‚Äë16 <input id="fit16" type="checkbox" checked /></label>

<!-- ADD: Audio-only toggle -->
<label>Audio‚Äëonly <input id="audioOnly" type="checkbox" /></label>

<span style="display:flex;gap:6px;margin-left:8px">
<button id="btnRecNow" class="btn">‚è∫ Rec Now</button>
<button id="btnRecRestart" class="btn">‚è∫ Rec Restart</button>
<button id="btnRecStop" class="btn" disabled>‚èπ Stop Rec</button>
<a id="recDownload" class="btn" style="display:none" download>‚¨áÔ∏è Save</a>
</span>

<span style="display:flex;gap:6px;margin-left:8px;flex-wrap:wrap">
<label>Solfeggio <input id="solfEnable" type="checkbox" /></label>
<label>Type <select id="solfType"><option value="binaural" selected>Binaural</option><option value="mono">Mono</option></select></label>

<label>Freq
<select id="solfFreq">
<option value="174">174 Hz ‚Äì Foundation</option>
<option value="285">285 Hz ‚Äì Healing</option>
<option value="396">396 Hz ‚Äì Liberation</option>
<option value="417">417 Hz ‚Äì Change</option>
<option value="528" selected>528 Hz ‚Äì Transformation</option>
<option value="639">639 Hz ‚Äì Connection</option>
<option value="741">741 Hz ‚Äì Awakening</option>
<option value="852">852 Hz ‚Äì Intuition</option>
<option value="963">963 Hz ‚Äì Divine</option>
</select>
</label>
<label>Level <input id="solfLevel"type="range" min="0" max="0.40" step="0.01" value="0.12" /></label>
<span id="solfDetect" class="chip" style="margin-left:8px" title="Goertzel power at target">
Solf detect: --
</span>


<label style="margin-left:12px">Retune Mix <input id="tuneEnable" type="checkbox" /></label>
<label>Target
<select id="tuneFreq">
<option value="174">174 Hz ‚Äì Foundation</option>
<option value="285">285 Hz ‚Äì Healing</option>
<option value="396">396 Hz ‚Äì Liberation</option>
<option value="417">417 Hz ‚Äì Change</option>
<option value="440">440 Hz ‚Äì Standard</option>
<option value="528" selected>528 Hz ‚Äì Transformation</option>
<option value="639">639 Hz ‚Äì Connection</option>
<option value="741">741 Hz ‚Äì Awakening</option>
<option value="852">852 Hz ‚Äì Intuition</option>
<option value="963">963 Hz ‚Äì Divine</option>
</select>
</label>

</span>
<span id="tuneDetect" class="chip" style="margin-left:8px" title="Goertzel power at retune target">
Retune detect: --
</span>

<span style="display:flex;gap:6px;margin-left:8px">
<label>Continuous
<select id="contMode">
<option value="off" selected>Off</option>
<option value="next">Play Next</option>
<option value="loop">Loop</option>
</select>
</label>
</span>

<span style="margin-left:auto;display:flex;gap:6px">
<button class="btn" onclick="toggleWin('winChannels')" aria-label="Mixer">üéö</button>
<button class="btn" onclick="toggleWin('winEQ')" aria-label="EQ">üéõ</button>
<button class="btn" onclick="toggleWin('winPlaylist')" aria-label="Playlist">üìú</button>
<button class="btn" onclick="toggleWin('winLog')" aria-label="Log">üßæ</button>
<button class="btn" onclick="toggleWin('winLyrics')" aria-label="Lyrics">üìñ</button>
<button class="btn" onclick="toggleWin('winKaro')" aria-label="Karaoke">üé§</button>
<button class="btn" onclick="toggleWin('winKaroSettings')" aria-label="Karaoke Settings">‚öôÔ∏èüé§</button>

<button id="karoResetPos" class="btn" type="button" title="Karaoke window">
‚§¢üé§
</button>

<!-- NEW: whole-page fullscreen -->
<button id="btnPageFS" class="btn" aria-label="Full Screen" title="Full screen">‚õ∂</button>
</span>
</div>

<div id="winChannels" class="floatWin" style="width:98vw;left:8px;" role="dialog" aria-modal="false" aria-labelledby="winChannelsTitle">
<div class="winHeader">
<strong id="winChannelsTitle">üéö Mixer</strong><span class="winBtns"><button class="btn" onclick="toggleWin('winChannels')">‚úï</button></span>
</div>
<div class="winBody">
<div id="chToolbar" class="row" style="margin-bottom:6px;justify-content:space-between">
<span class="chip" id="usedSummary">Used 0/16</span>
<span class="chip" id="activeSummary">Now 0</span>
<button id="btnResetUsed" class="btn">‚Ü∫</button>
</div>
<div id="chGridVert" aria-label="Channel Mixer"></div>
</div>
</div>

<div id="winEQ" class="floatWin" style="width:320px;" role="dialog" aria-modal="false" aria-labelledby="winEQTitle">
<div class="winHeader">
<strong id="winEQTitle">üéõ EQ</strong><span class="winBtns"><button class="btn" onclick="toggleWin('winEQ')">‚úï</button></span>
</div>
<div class="winBody">
<div class="row" style="flex-direction:column;gap:6px;font-size:10px">
<label>31 <input id="eq10_0" type="range" min="-12" max="12" value="0" step="1" aria-label="31 Hz" /></label>
<label>62 <input id="eq10_1" type="range" min="-12" max="12" value="0" step="1" aria-label="62 Hz" /></label>
<label>125<input id="eq10_2" type="range" min="-12" max="12" value="0" step="1" aria-label="125 Hz" /></label>
<label>250<input id="eq10_3" type="range" min="-12" max="12" value="0" step="1" aria-label="250 Hz" /></label>
<label>500<input id="eq10_4" type="range" min="-12" max="12" value="0" step="1" aria-label="500 Hz" /></label>
<label>1k<input id="eq10_5" type="range" min="-12" max="12" value="0" step="1" aria-label="1 kHz" /></label>
<label>2k<input id="eq10_6" type="range" min="-12" max="12" value="0" step="1" aria-label="2 kHz" /></label>
<label>4k<input id="eq10_7" type="range" min="-12" max="12" value="0" step="1" aria-label="4 kHz" /></label>
<label>8k<input id="eq10_8" type="range" min="-12" max="12" value="0" step="1" aria-label="8 kHz" /></label>
<label>16k<input id="eq10_9" type="range" min="-12" max="12" value="0" step="1" aria-label="16 kHz" /></label>
<button id="btnCalm" class="btn">üß∞ Calm</button>
</div>
</div>
</div>

<div id="winPlaylist" class="floatWin" style="width:320px;" role="dialog" aria-modal="false" aria-labelledby="winPlaylistTitle">
<div class="winHeader">
<strong id="winPlaylistTitle">üìú List</strong><span class="winBtns"><button class="btn" onclick="toggleWin('winPlaylist')">‚úï</button></span>
</div>
<div class="winBody">
<div id="plList"></div>
</div>
</div>

<div id="winLog" class="floatWin" style="width:320px;" role="dialog" aria-modal="false" aria-labelledby="winLogTitle">
<div class="winHeader">
<strong id="winLogTitle">üßæ Log</strong><span class="winBtns"><button class="btn" onclick="toggleWin('winLog')">‚úï</button></span>
</div>
<button id="btnClearLog" class="btn" type="button" title="Clear status log">üßπ Clear Log</button>

<div class="winBody">
<pre id="status" class="log" role="status" aria-live="polite">Ready (v5.4b.1‚Äëperf). Mixer DOM built once; per‚Äëframe updates are meter bars + counters only. Mobile/desktop responsive tweaks applied. Recording + Solfeggio overlay + Master Retune + Continuous Play + Lyrics + Karaoke. Global error logging enabled. Settings persisted to localStorage. Karaoke window frame/header/body follow Karaoke BG (no bands). Bugfixes applied.</pre>
</div>
</div>

<div id="winLyrics" class="floatWin" style="width:460px;" role="dialog" aria-modal="false" aria-labelledby="winLyricsTitle">
<div class="winHeader">
<strong id="winLyricsTitle">üìñ Lyrics</strong>
<span class="winBtns"><button class="btn" onclick="toggleWin('winLyrics')">‚úï</button></span>
</div>
<div class="winBody" style="font-size:11px">
<div style="display:flex; gap:6px; flex-wrap:wrap; align-items:center; margin-bottom:8px">

<label>Source
  <select id="lySrc">
    <!-- Default: Auto single-source -->
    <option value="auto" selected>Auto (single-source)</option>

    <!-- Single-type options -->
    <option value="05">0x05 only (Lyric)</option>
    <option value="01">0x01 only (Text)</option>
    <option value="03">0x03 only (Track Name)</option>
  </select>
</label>

<label><input type="checkbox" id="lyPreserve" checked> Preserve spaces</label>
<label><input type="checkbox" id="lySplitSlash" checked> Split on ‚Äú/‚Äù</label>
<label>Encoding
  <select id="lyEnc">
    <option value="auto" selected>Auto (UTF‚Äë8 ‚Üí Latin‚Äë1 ‚Üí Raw)</option>
    <option value="latin1">Latin‚Äë1</option>
    <option value="utf8">UTF‚Äë8</option>
  </select>
</label>
<button class="btn" id="btnLyFull">Full</button>
<button class="btn" id="btnLyTokens">Tokens</button>
</div>


<div id="lyPrev" style="color:#9fbad1; margin:4px 0 2px"></div>
<div id="lyCurr" style="font-weight:700; margin:2px 0 2px"></div>
<div id="lyNext" style="color:#b6c9dc; margin:2px 0 6px"></div>

<div id="lyFull" style="display:none;"></div>
<div id="lyTokens" style="display:none;"></div>
</div>
</div>

<div id="winKaro" class="floatWin" style="width:680px;" role="dialog" aria-modal="false" aria-labelledby="winKaroTitle">
<div class="winHeader">
<strong id="winKaroTitle">karaokeHD</strong>
<span class="winBtns">
<button class="btn" id="btnKaroFS" title="Fullscreen" aria-pressed="false">‚õ∂</button>
<button class="btn" onclick="toggleWin('winKaro')">‚úï</button>
</span>
</div>
<div class="winBody" style="font-size:11px">
<div id="karoCurr"></div>
<div id="karoNext"></div>
</div>
</div>

<div id="winKaroSettings" class="floatWin" style="width:520px;" role="dialog" aria-modal="false" aria-labelledby="winKaroSettingsTitle">
<div class="winHeader">
<strong id="winKaroSettingsTitle">‚öôÔ∏è Karaoke Settings</strong>
<span class="winBtns"><button class="btn" onclick="toggleWin('winKaroSettings')">‚úï</button></span>
</div>
<div class="winBody" style="font-size:11px">
<div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px">
<label>Align <select id="karoAlign"><option value="left">Left</option><option value="center" selected>Center</option></select></label>
<label><input type="checkbox" id="karoLettersOnly"> Letters‚Äëonly</label>
<label><input type="checkbox" id="karoChromaSafe" checked> Chroma‚Äësafe</label>
<label><input type="checkbox" id="karoMicroStroke" checked> Micro‚Äëstroke</label>
<label><input type="checkbox" id="karoAOD"> AOD (prevent sleep)</label>
<label>Fill <input type="color" id="karoFill" value="#00b3ff"></label>
<label>Base <input type="color" id="karoBase" value="#ffffff"></label>
<label>BG   <input type="color" id="karoBg" value="#000000"></label>
<label>Glow <input type="range" id="karoGlow" min="0" max="24" step="1" value="10"></label>
<label>Stroke <input type="range" id="karoStrokeW" min="0" max="6" step="0.5" value="1"></label>
<label>Blend <select id="karoBlend"><option value="normal" selected>Normal</option><option value="screen">Screen</option><option value="overlay">Overlay</option><option value="lighten">Lighten</option><option value="multiply">Multiply</option></select></label>
<label>Weight <input type="range" id="karoWeight" min="300" max="900" step="50" value="800"></label>
<label>Letter‚Äëspacing (em) <input type="range" id="karoLS" min="-0.02" max="0.20" step="0.01" value="0"></label>
<label>Token gap (em) <input type="range" id="karoGap" min="0" max="0.30" step="0.01" value="0.04"></label>
<label>Case <select id="karoCase"><option value="none" selected>As is</option><option value="upper">ALL CAPS</option><option value="lower">all small</option><option value="cap">Cap Each Word</option><option value="sentence">Sentence</option></select></label>
</div>
</div>


<!-- ‚öôÔ∏è Karaoke Settings ‚Ä∫ Font -->

<div class="ks-row" id="ks-font-upload-row">
<input id="ks-font-file" type="file" accept=".ttf,.otf,.woff,.woff2" />
<button id="ks-font-use-upload" class="ks-btn">Use uploaded (no server)</button>
<button id="ks-font-save-idb" class="ks-btn">Save locally (IndexedDB)</button>
</div>

<label class="ks-label">Lyrics font</label>
<select id="ks-font-family" class="ks-input"></select>
<small class="ks-note">Applies to <b>#karoCurr</b> and <b>#karoNext</b>.</small>

<div class="ks-row">
<button id="ks-scan-device-fonts" class="ks-btn">List device fonts (if supported)</button>
<span id="ks-device-fonts-status" class="ks-note"></span>
</div>

<div class="ks-row">
<input id="ks-font-manual-name" class="ks-input" placeholder="Type a device font name‚Ä¶ e.g., 'Calibri'" />
<button id="ks-test-manual-font" class="ks-btn">Test & apply</button>
</div>
</div>




<script>
const MUTE_FACTOR = 0.0; const STORAGE_KEY = 'MIDI_POC_Ultra_v5.4b.1';
const log = (msg)=> {
const el = document.getElementById('status'); el.textContent += `\n${msg}`; el.scrollTop = el.scrollHeight;
};
window.addEventListener('error', (e)=> {
try {
log('JS Error: ' + (e.message || e));
}catch(_) {}
});

function clearStatusLog() {
  const el = document.getElementById('status');
  if (!el) return;

  // Stop auto-scroll, clear text, then resume auto-scroll
  const wasAtBottom = Math.abs(el.scrollHeight - el.scrollTop - el.clientHeight) < 4;
  el.textContent = '';
  // Keep the behavior consistent: auto-scroll only if it was already at bottom
  if (wasAtBottom) el.scrollTop = el.scrollHeight;
}

let zCounter = 10000;
function toggleWin(id) {
const w = document.getElementById(id); if (!w) return; const show = (w.style.display === 'none' || w.style.display === ''); w.style.display = show? 'block': 'none'; if (show) {
w.style.zIndex = (++zCounter).toString();
} settings.windows = settings.windows || {}; settings.windows[id] = settings.windows[id] || {}; settings.windows[id].display = w.style.display; persistSettings();
}

(function() {
  const wins = ['winChannels', 'winEQ', 'winPlaylist', 'winLog', 'winLyrics', 'winKaro', 'winKaroSettings'];

  for (const id of wins) {
    const w = document.getElementById(id);
    if (!w) continue;
    const hdr = w.querySelector('.winHeader');
    if (!hdr) continue;

    let dragging = false;
    let ox = 0, oy = 0;

    hdr.addEventListener('pointerdown', (e) => {
      try {
        dragging = true;
        w.style.zIndex = (++zCounter).toString();

        const rect = w.getBoundingClientRect();
        ox = e.clientX - rect.left;
        oy = e.clientY - rect.top;

        hdr.setPointerCapture?.(e.pointerId);
        document.body.style.userSelect = 'none';
      } catch(_) {}
    });

    hdr.addEventListener('pointermove', (e) => {
      if (!dragging) return;
      try {
        e.preventDefault(); // allow no-scroll during drag
        w.style.left = (e.clientX - ox) + 'px';
        w.style.top  = (e.clientY - oy) + 'px';
      } catch(_) {}
    });

    hdr.addEventListener('pointerup', (e) => {
      try {
        dragging = false;
        document.body.style.userSelect = 'auto';
        settings.windows = settings.windows || {};
        settings.windows[id] = settings.windows[id] || {};
        settings.windows[id].left   = w.style.left;
        settings.windows[id].top    = w.style.top;
        settings.windows[id].width  = w.style.width;
        settings.windows[id].display= w.style.display;
        persistSettings();
      } catch(_) {}
    });
  }
})();

const INST_SYM = {
pianoLite: 'üéπ', deepBass: 'üß±', guitar: 'üé∏', drumLite: 'ü•Å', triangle: '‚ñ≥', square: '‚ñ¢', saw: '‚ö°', fm: '‚àø'
};
function instSymbol(name) {
return INST_SYM[name] || '‚ó¶';
}
¬†
// Simple 16-channel fallback (0..15). Edit values to your taste.
// Keep ch 9 = 'drumLite' for GM drums.
const CH_TO_INST = [
  'pianoLite', // ch 0
  'deepBass',  // ch 1
  'guitar',    // ch 2
  'square',    // ch 3
  'triangle',  // ch 4
  'triangle',  // ch 5
  'square',    // ch 6
  'saw',       // ch 7
  'square',    // ch 8
  'drumLite',  // ch 9  (GM drums)
  'saw',       // ch 10
  'square',    // ch 11
  'triangle',  // ch 12
  'saw',       // ch 13
  'square',    // ch 14
  'pianoLite'  // ch 15
];

function chanFallbackInst(ch) {
  return CH_TO_INST[ch] ?? 'pianoLite';
}


let audioCtx = null; let masterIn = null; let masterOut = null; let transport = null; let hpf = null; let notch = null; let clip = null; let analyser = null;
let mediaDest = null; let mediaRecorder = null; let recChunks = [];
const EQ_FREQS = [31, 62, 125, 250, 500, 1000, 2000, 4000, 8000, 16000]; let eqBands = [];
let useTriangle = false; let antiBeep = true; let autoRecovery = true; let autoAssign = true; let palette = 'classic';
const MIN_NOTE_MS_MELODY = 140, MIN_NOTE_MS_DRUMS = 110, GAP_SEC = 0.150; const ENV_ATTACK = 0.010, ENV_RELEASE = 0.090;

let vizCanvas = null, vizCtx = null, vizBuffer = null, vizBufferF = null;

let solfEnable = false, solfType = 'binaural', solfFreq = 528.0; const BEAT_DELTA_HZ = 4.0; let solfGainNode = null, solfOscL = null, solfOscR = null, solfPanL = null, solfPanR = null;
let tuneEnable = false, tuneFreq = 528.0, globalDetuneRatio = 1.0; let contMode = 'off';

const channels = Array(16).fill(null).map((_, i)=>({
gain: null, pan: null, baseGain: (i === 9?1.0: 0.70), expr: 1.0, sustain: false, bend: 0, inst: chanFallbackInst(i), lastNote: null, locked: false, prog: null, mute: false, solo: false
}));
const chAct = Array(16).fill(null).map(()=>({
level: 0, last: 0
})); const chSeen = Array(16).fill(false);
const voices = []; const seq = {
events: [],
startTime: 0,
startTick: 0,
ptr: 0,
running: false,
lookAhead: 0.03,
scheduleAhead: 0.20,
timer: null
}; const playlist = []; let currentIndex=-1; let _tempo = null;
const FAILSAFE_TABLE = {
drumLite: {
lvl: 0.40,
idle: 1.8
},
deepBass: {
lvl: 0.35,
idle: 1.6
},
pianoLite: {
lvl: 0.32,
idle: 1.6
},
guitar: {
lvl: 0.30,
idle: 1.8
},
triangle: {
lvl: 0.28,
idle: 2.0
},
square: {
lvl: 0.28,
idle: 2.0
},
saw: {
lvl: 0.28,
idle: 2.0
},
fm: {
lvl: 0.30,
idle: 1.8
}
};

const defaults = {
lyrics: {
source: '05',
preserveSpaces: true,
splitOnSlash: true,
enc: 'latin1'
},
karaoke: {
align: 'center',
lettersOnly: false,
chromaSafe: true,
microStroke: true,
aod: false,
fill: '#f31260',
base: '#ffffff',
bg: '#00ff00',
glow: 10,
strokeW: 1,
blend: 'normal',
weight: 800,
letterSpacing: 0,
tokenGap: 0.04,
case: 'none'
},
ui: {
density: 'ultra',
fit16: true,
palette: 'classic',
preset: 'Flat',
contMode: 'off',
autoAssign: true,
autoRecovery: true,
audioOnly: false
},
audio: {
limiter: 0.78,
notch: 60,
solfEnable: false,
solfType: 'binaural',
solfFreq: 528,
solfLevel: 0.12,
tuneEnable: false,
tuneFreq: 528
},
windows: {}
};
let settings = loadSettings(); function loadSettings() {
try {
const s = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); return deepMerge(JSON.parse(JSON.stringify(defaults)), s || {});
}catch(e) {
return JSON.parse(JSON.stringify(defaults));
}
}
function persistSettings() {
try {
localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
}catch(e) {}
}


function deepMerge(a, b) {
for (const k of Object.keys(b)) {
if (b[k] && typeof b[k] === 'object'&&!Array.isArray(b[k])) {
if (!a[k] || typeof a[k] !== 'object') {
a[k] = {};
} a[k] = deepMerge(a[k], b[k]);
} else {
a[k] = b[k];
}
} return a;
}

const lyrics = {
source: settings.lyrics.source,
preserveSpaces: settings.lyrics.preserveSpaces,
splitOnSlash: settings.lyrics.splitOnSlash,
enc: settings.lyrics.enc,
json: {
lines: []},
startAt: 0,
raf: 0
};
const KaroState = {
linesPrepared: [],
lettersOnly: settings.karaoke.lettersOnly,
raf: 0,
startAt: 0,
align: settings.karaoke.align,
case: settings.karaoke.case
};

let mixerBuilt = false; const meterBars = new Array(16); const titleBadges = new Array(16);

// === Audio-only helpers (ADD) ===
let audioOnly = false; // runtime flag mirrors settings.ui.audioOnly
let drawVizEnabled = true; // gate for visualizer loop
let goertzelEnabled = true; // gate for detectors loop
// Track RAF IDs so we can cancel safely when toggling
let _vizRAF = 0;
let _goertzelRAF = 0;
// ADD: track analyser bypass wiring
let analyserBypassed = false;

// ADD: rewire final stage with or without analyser

function wireFinalStage(useAnalyser) {
  if (!clip || !transport) return;
  try {
    // Disconnect previous
    try { clip.disconnect(); } catch (_) {}

    if (useAnalyser && analyser) {
      // clip ‚Üí analyser ‚Üí transport
      clip.connect(analyser);
      try { analyser.disconnect(); } catch (_) {}
      analyser.connect(transport);
    } else {
      // clip ‚Üí transport
      clip.connect(transport);
    }

    // Ensure transport outputs are consistent
    try { transport.disconnect(); } catch (_) {}
    transport.connect(masterOut);
    transport.connect(mediaDest);
  } catch (e) {
    try { log('Wire error: ' + (e.message || e)); } catch (_) {}
  }
}

function applyAudioOnlyUI(on) {
  audioOnly = !!on;
  document.body.classList.toggle('audio-only', audioOnly);

  // NEW: rewire analyser in/out immediately
  analyserBypassed = audioOnly;
  try { wireFinalStage(!analyserBypassed); } catch(_) {}

  if (audioOnly) {
    drawVizEnabled   = false;
    goertzelEnabled  = false;
    try { if (_vizRAF)      cancelAnimationFrame(_vizRAF);      } catch(_) {}
    try { if (_goertzelRAF) cancelAnimationFrame(_goertzelRAF); } catch(_) {}
    try { LyricsLive.stop(); } catch(_) {}
    try { Karo.stop();       } catch(_) {}
  } else {
    drawVizEnabled   = true;
    goertzelEnabled  = true;
    try { _vizRAF      = requestAnimationFrame(drawWave);         } catch(_) {}
    try { _goertzelRAF = requestAnimationFrame(goertzelDetectLoop);} catch(_) {}
  }
}

function buildMixerOnce() {
if (mixerBuilt) return; const grid = document.getElementById('chGridVert'); grid.innerHTML = ''; for (let ch = 0; ch < 16; ch++) {
const st = channels[ch]; const act = chAct[ch]; const strip = document.createElement('div'); strip.className = 'strip'; strip.dataset.ch = ch; strip.title = (ch+1)+' '+(st.inst || '')+(st.locked?' üîí': ''); const ttl = document.createElement('div'); ttl.className = 'title'; const name = document.createElement('strong'); name.textContent = String(ch+1); ttl.appendChild(name); const badge = document.createElement('span'); badge.className = 'badge'; badge.textContent = instSymbol(st.inst || 'triangle'); ttl.appendChild(badge); titleBadges[ch] = badge; strip.appendChild(ttl); const meter = document.createElement('div'); meter.className = 'vMeter'; const bar = document.createElement('div'); bar.className = 'bar'; bar.style.height = Math.min(100, Math.floor((act.level || 0)*100))+'%'; meter.appendChild(bar); strip.appendChild(meter); meterBars[ch] = bar; const controls = document.createElement('div'); controls.className = 'controls'; const ctl = document.createElement('div'); ctl.className = 'ctlV'; const sel = document.createElement('select'); sel.className = 'symSel'; sel.innerHTML = '<option value="triangle">‚ñ≥</option>'+'<option value="saw">‚ö°</option>'+'<option value="square">‚ñ¢</option>'+'<option value="guitar">üé∏</option>'+'<option value="deepBass">üß±</option>'+(ch === 9?'<option value="drumLite" selected>ü•Å</option>': '<option value="pianoLite">üéπ</option>'); sel.value = (st.inst || 'triangle'); sel.addEventListener('change', (e)=> {
st.inst = e.target.value; st.locked = true; titleBadges[ch].textContent = instSymbol(st.inst); strip.title = (ch+1)+' '+(st.inst || '')+' üîí';
}); ctl.appendChild(sel); const lock = document.createElement('label'); const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = st.locked; cb.addEventListener('change', (e)=> {
st.locked = e.target.checked; strip.title = (ch+1)+' '+(st.inst || '')+(st.locked?' üîí': '');
}); lock.appendChild(cb); lock.appendChild(document.createTextNode('üîí')); ctl.appendChild(lock); const m = document.createElement('label'); const mcb = document.createElement('input'); mcb.type = 'checkbox'; mcb.checked = st.mute; mcb.addEventListener('change', (e)=> {
st.mute = e.target.checked; updateMixGains();
}); m.appendChild(mcb); m.appendChild(document.createTextNode('M')); m.className = 'muted'; ctl.appendChild(m); const s = document.createElement('label'); const scb = document.createElement('input'); scb.type = 'checkbox'; scb.checked = st.solo; scb.addEventListener('change', (e)=> {
st.solo = e.target.checked; updateMixGains();
}); s.appendChild(scb); s.appendChild(document.createTextNode('S')); s.className = 'solo'; ctl.appendChild(s); controls.appendChild(ctl); strip.appendChild(controls); grid.appendChild(strip);
} mixerBuilt = true; refreshMixerCounters(true);
}
function refreshMixerCounters(force = false) {
const now = audioCtx? audioCtx.currentTime: 0; let usedCount = 0,
activeNow = 0; for (let ch = 0; ch < 16; ch++) {
const a = chAct[ch]; const isActiveNow = (now - (a.last || 0)) < 1.2 || (a.level > 0.02); if (isActiveNow) activeNow++; if (chSeen[ch]) usedCount++;
} const usedEl = document.getElementById('usedSummary'); const actEl = document.getElementById('activeSummary'); if (force || usedEl._val !== usedCount) {
usedEl.textContent = 'Used '+usedCount+'/16'; usedEl._val = usedCount;
} if (force || actEl._val !== activeNow) {
actEl.textContent = 'Now '+activeNow; actEl._val = activeNow;
}
}
function updateMixerMeters() {
for (let ch = 0; ch < 16; ch++) {
const a = chAct[ch]; const bar = meterBars[ch]; if (!bar) continue; const h = Math.min(100, Math.floor((a.level || 0)*100)); if (bar._h !== h) {
bar.style.height = h+'%'; bar._h = h;
}
} refreshMixerCounters();
}

//

    
function bindUI() {
    document.getElementById('btnClearLog').addEventListener('click', () => {
  clearStatusLog();
  // Optional trace so you know it was cleared
  try { log('Log cleared.'); } catch(_) {}
});
document.getElementById('btnInit').addEventListener('click', initAudio); document.getElementById('midFiles').addEventListener('change', onAddFiles); document.getElementById('btnPlay').addEventListener('click', ()=>startPlayback(true)); document.getElementById('btnStop').addEventListener('click', stopPlayback); document.getElementById('btnPanic').addEventListener('click', panicAll); document.getElementById('btnCalm').addEventListener('click', applyCalm); document.getElementById('preset').addEventListener('change', (e)=> {
settings.ui.preset = e.target.value; persistSettings(); applyPreset(settings.ui.preset);
}); document.getElementById('limStr').addEventListener('input', (e)=> {
settings.audio.limiter = parseFloat(e.target.value || '0.78'); persistSettings(); onLimiter();
}); document.getElementById('notch').addEventListener('change', (e)=> {
settings.audio.notch = parseFloat(e.target.value || '0'); persistSettings(); onNotch();
}); (() => {
const ss = document.getElementById('softSynth'); if (ss) ss.addEventListener('change', (e)=> {
useTriangle = e.target.checked; log('Soft Synth '+(useTriangle?'ON': 'OFF'));
}); const ab = document.getElementById('antiBeep'); if (ab) ab.addEventListener('change', (e)=> {
antiBeep = e.target.checked; log('Anti‚ÄëBeep '+(antiBeep?'ON': 'OFF'));
});
})(); const palSel = document.getElementById('palette'); if (palSel) palSel.addEventListener('change', (e)=> {
settings.ui.palette = e.target.value; persistSettings(); palette = settings.ui.palette; log('Palette '+palette); for (let ch = 0; ch < 16; ch++) {
if (!channels[ch].locked) maybeAutoAssign(ch); titleBadges[ch].textContent = instSymbol(channels[ch].inst);
}
}); for (let i = 0; i < 10; i++) {
const el = document.getElementById('eq10_'+i); if (el) el.addEventListener('input', onEq10Slider);
} document.getElementById('density').addEventListener('change', (e)=> {
settings.ui.density = e.target.value; persistSettings(); applyDensity(settings.ui.density);
}); document.getElementById('fit16').addEventListener('change', (e)=> {
settings.ui.fit16 = e.target.checked; persistSettings(); fit16Active = settings.ui.fit16; autoFit16();
}); window.addEventListener('resize', ()=> {
setupVizCanvas(); if (fit16Active) autoFit16();
}); const list = document.getElementById('plList'); const onListTap = (e)=> {
const item = e.target.closest('.plItem'); if (!item) return; selectTrack(+item.dataset.index);
}; list.addEventListener('click', onListTap); list.addEventListener('touchstart', onListTap, {
passive: true
}); document.getElementById('btnResetUsed').addEventListener('click', ()=> {
for (let i = 0; i < 16; i++) {
chSeen[i] = false; chAct[i].level = 0; chAct[i].last = 0;
} refreshMixerCounters(true); updateMixerMeters();
}); document.getElementById('btnRecNow').addEventListener('click',
()=>startRecording('current')); document.getElementById('btnRecRestart').addEventListener('click',
()=>startRecording('restart')); document.getElementById('btnRecStop').addEventListener('click',
stopRecording); document.getElementById('solfEnable').addEventListener('change',
(e)=> {
settings.audio.solfEnable = !!e.target.checked; persistSettings(); solfEnable = settings.audio.solfEnable; log('Solfeggio '+(solfEnable?'ON': 'OFF')); updateSolfeggio();
}); document.getElementById('solfType').addEventListener('change',
(e)=> {
settings.audio.solfType = e.target.value; persistSettings(); solfType = settings.audio.solfType; log('Solf Type '+solfType); updateSolfeggio(true);
}); document.getElementById('solfFreq').addEventListener('change',
(e)=> {
settings.audio.solfFreq = parseFloat(e.target.value || '528'); persistSettings(); solfFreq = settings.audio.solfFreq; log('Solf Freq '+solfFreq+' Hz'); updateSolfeggio();
}); document.getElementById('solfLevel').addEventListener('input',
(e)=> {
const v = parseFloat(e.target.value || '0.12'); settings.audio.solfLevel = v; persistSettings(); if (solfGainNode) try {
solfGainNode.gain.setTargetAtTime(v, audioCtx.currentTime, 0.05);
}catch(err) {}
}); document.getElementById('tuneEnable').addEventListener('change',
(e)=> {
settings.audio.tuneEnable = !!e.target.checked; persistSettings(); tuneEnable = settings.audio.tuneEnable; updateRetune(); log('Retune '+(tuneEnable?'ON': 'OFF'));
}); document.getElementById('tuneFreq').addEventListener('change',
(e)=> {
settings.audio.tuneFreq = parseFloat(e.target.value || '528'); persistSettings(); tuneFreq = settings.audio.tuneFreq; updateRetune(); log('Retune target '+tuneFreq+' Hz');
}); document.getElementById('contMode').addEventListener('change',
(e)=> {
settings.ui.contMode = e.target.value; persistSettings(); contMode = settings.ui.contMode; log('Continuous '+contMode);
}); const asnSel = document.getElementById('autoAssign'); if (asnSel) asnSel.addEventListener('change', (e)=> {
settings.ui.autoAssign = (e.target.value === '1'); persistSettings(); autoAssign = settings.ui.autoAssign; log('Assign '+(autoAssign?'ON': 'OFF'));
}); const recSel = document.getElementById('autoRecovery'); if (recSel) recSel.addEventListener('change', (e)=> {
settings.ui.autoRecovery = (e.target.value === '1'); persistSettings(); autoRecovery = settings.ui.autoRecovery; log('Recovery '+(autoRecovery?'ON': 'OFF'));
}); 
(function() {
  const srcSel = document.getElementById('lySrc');
  const cbPres = document.getElementById('lyPreserve');
  const cbSlash = document.getElementById('lySplitSlash');
  const encSel = document.getElementById('lyEnc');
  const btnFull = document.getElementById('btnLyFull');
  const btnTok  = document.getElementById('btnLyTokens');

  // Helper: stop live loops and clear containers to avoid stale views
  async function refreshLyricsAfterChange() {
    try { LyricsLive.stop(); } catch(_) {}
    try { Karo.stop(); } catch(_) {}

    // Clear static areas
    for (const id of ['lyPrev','lyCurr','lyNext','lyFull','lyTokens']) {
      const el = document.getElementById(id);
      if (el) el.innerHTML = '';
    }

    // Reset prepared state
    try {
      KaroState.linesPrepared = [];
      KaroState.raf = 0;
      lyrics.raf = 0;
    } catch(_) {}

    // Reparse current song using single-source + auto encoding (implemented in ensureParsed)
    const ok = await ensureParsed();
    if (!ok) return;

    // Re-render static and restart live engines
    renderLyricsStatic();
    try { LyricsLive.rebuild(); } catch(_) {}
    try { Karo.rebuild(); } catch(_) {}
  }

  // === Lyric Source: Auto (single-source) or fixed 0x05/0x01/0x03 (no mixing) ===
  if (srcSel) {
    srcSel.addEventListener('change', async (e)=> {
      const val = e.target.value || 'auto'; // treat any combo as 'auto single-source'
      settings.lyrics.source = val;
      persistSettings();
      lyrics.source = settings.lyrics.source;
      await refreshLyricsAfterChange();
    });
  }

  // === Preserve spaces toggle ===
  if (cbPres) {
    cbPres.addEventListener('change', async (e)=> {
      settings.lyrics.preserveSpaces = !!e.target.checked;
      persistSettings();
      lyrics.preserveSpaces = settings.lyrics.preserveSpaces;
      await refreshLyricsAfterChange();
    });
  }

  // === Split on slash toggle ===
  if (cbSlash) {
    cbSlash.addEventListener('change', async (e)=> {
      settings.lyrics.splitOnSlash = !!e.target.checked;
      persistSettings();
      lyrics.splitOnSlash = settings.lyrics.splitOnSlash;
      await refreshLyricsAfterChange();
    });
  }

  // === Encoding: enforce auto detect ===
  if (encSel) {
    encSel.addEventListener('change', async (e)=> {
      // You can optionally ignore UI and force auto‚Ä¶
      settings.lyrics.enc = 'auto';
      lyrics.enc = 'auto';
      persistSettings();
      // ‚Ä¶or reflect the enforcement in the dropdown
      try { encSel.value = 'auto'; } catch(_) {}
      await refreshLyricsAfterChange();
    });
  }

  // View toggles (unchanged)
  if (btnFull) btnFull.addEventListener('click', ()=> {
    document.getElementById('lyFull').style.display = 'block';
    document.getElementById('lyTokens').style.display = 'none';
  });
  if (btnTok) btnTok.addEventListener('click', ()=> {
    document.getElementById('lyFull').style.display = 'none';
    document.getElementById('lyTokens').style.display = 'block';
  });

  // Initial values
  if (srcSel)   srcSel.value    = settings.lyrics.source || 'auto';
  if (cbPres)   cbPres.checked  = settings.lyrics.preserveSpaces;
  if (cbSlash)  cbSlash.checked = settings.lyrics.splitOnSlash;
  if (encSel)   encSel.value    = (settings.lyrics.enc || 'auto');
})();
(function() {
const win = document.getElementById('winKaro'); function setAlign(v) {
win.classList.toggle('karo-align-left',
v === 'left'); win.classList.toggle('karo-align-center',
v === 'center'); KaroState.align = v; settings.karaoke.align = v; persistSettings();
} function setFill(v) {
win.style.setProperty('--kara-fill',
v || '#00b3ff'); settings.karaoke.fill = v; persistSettings();
} function setBase(v) {
win.style.setProperty('--kara-base',
v || '#ffffff'); settings.karaoke.base = v; persistSettings();
} function setBg(v) {
win.style.setProperty('--kara-bg',
v || 'rgba(0,0,0,0)'); settings.karaoke.bg = v; persistSettings();
} function setGlow(n) {
win.style.setProperty('--glow-radius',
String(n || 0)+'px'); win.style.setProperty('--glow-radius2',
String((n || 0)*1.4)+'px'); settings.karaoke.glow = n; persistSettings();
} function setStrokeW(n) {
win.style.setProperty('--kara-stroke-w',
String(Math.max(0, n || 0))+'px'); settings.karaoke.strokeW = n; persistSettings();
} function setBlend(v) {
win.style.setProperty('--kara-blend',
v || 'normal'); settings.karaoke.blend = v; persistSettings();
} function setWeight(n) {
win.style.setProperty('--kara-weight',
String(n || 800)); settings.karaoke.weight = n; persistSettings();
} function setLS(n) {
win.style.setProperty('--kara-letter-spacing',
String(n || 0)+'em'); settings.karaoke.letterSpacing = n; persistSettings();
} function setGap(n) {
win.style.setProperty('--kara-token-gap',
String(n || 0)+'em'); settings.karaoke.tokenGap = n; persistSettings();
} function setCase(v) {
KaroState.case = v || 'none'; settings.karaoke.case = v; persistSettings();
} function setChromaSafe(b) {
win.classList.toggle('karo-chroma-safe',
!!b); settings.karaoke.chromaSafe=!!b; persistSettings();
} function setMicroStroke(b) {
win.classList.toggle('karo-micro-stroke',
!!b); settings.karaoke.microStroke=!!b; persistSettings();
} const $ = (id)=>document.getElementById(id); $('karoAlign').addEventListener('change',
(e)=>setAlign(e.target.value)); $('karoLettersOnly').addEventListener('change',
(e)=> {
KaroState.lettersOnly = !!e.target.checked; settings.karaoke.lettersOnly=!!e.target.checked; persistSettings();
}); $('karoChromaSafe').addEventListener('change',
(e)=>setChromaSafe(e.target.checked)); $('karoMicroStroke').addEventListener('change',
(e)=>setMicroStroke(e.target.checked)); $('karoFill').addEventListener('input',
(e)=>setFill(e.target.value)); $('karoBase').addEventListener('input',
(e)=>setBase(e.target.value)); $('karoBg').addEventListener('input',
(e)=>setBg(e.target.value)); $('karoGlow').addEventListener('input',
(e)=>setGlow(parseFloat(e.target.value || '0'))); $('karoStrokeW').addEventListener('input',
(e)=>setStrokeW(parseFloat(e.target.value || '0'))); $('karoBlend').addEventListener('change',
(e)=>setBlend(e.target.value)); $('karoWeight').addEventListener('input',
(e)=>setWeight(parseInt(e.target.value || '800', 10))); $('karoLS').addEventListener('input',
(e)=>setLS(parseFloat(e.target.value || '0'))); $('karoGap').addEventListener('input',
(e)=>setGap(parseFloat(e.target.value || '0'))); $('karoCase').addEventListener('change',
(e)=>setCase(e.target.value)); setAlign(settings.karaoke.align); setChromaSafe(settings.karaoke.chromaSafe); setMicroStroke(settings.karaoke.microStroke); setFill(settings.karaoke.fill); setBase(settings.karaoke.base); setBg(settings.karaoke.bg); setGlow(settings.karaoke.glow); setStrokeW(settings.karaoke.strokeW); setBlend(settings.karaoke.blend); setWeight(settings.karaoke.weight); setLS(settings.karaoke.letterSpacing); setGap(settings.karaoke.tokenGap); setCase(settings.karaoke.case); $('karoLettersOnly').checked = settings.karaoke.lettersOnly; $('karoAlign').value = settings.karaoke.align; $('karoChromaSafe').checked = settings.karaoke.chromaSafe; $('karoMicroStroke').checked = settings.karaoke.microStroke; $('karoFill').value = settings.karaoke.fill; $('karoBase').value = settings.karaoke.base; $('karoBg').value = settings.karaoke.bg; $('karoGlow').value = settings.karaoke.glow; $('karoStrokeW').value = settings.karaoke.strokeW; $('karoBlend').value = settings.karaoke.blend; $('karoWeight').value = settings.karaoke.weight; $('karoLS').value = settings.karaoke.letterSpacing; $('karoGap').value = settings.karaoke.tokenGap; $('karoCase').value = settings.karaoke.case; (function() {
const cb = document.getElementById('karoAOD'); cb.checked = !!settings.karaoke.aod; let wakeLock = null,
fallbackVideo = null; async function requestWL() {
if (!('wakeLock' in navigator)) {
fallback(); return;
} try {
wakeLock = await navigator.wakeLock.request('screen'); wakeLock.addEventListener('release', ()=> {
wakeLock = null;
});
}catch(err) {
fallback();
}
} async function releaseWL() {
try {
await wakeLock?.release?.();
}catch(_) {} wakeLock = null; if (fallbackVideo) {
try {
fallbackVideo.pause();
}catch(_) {} fallbackVideo.remove(); fallbackVideo = null;
}
} function fallback() {
if (fallbackVideo) return; const ac = audioCtx || new (window.AudioContext || window.webkitAudioContext)(); const osc = ac.createOscillator(); osc.frequency.value = 0.0001; const gain = ac.createGain(); gain.gain.value = 0.0; osc.connect(gain).connect(ac.destination); osc.start(); fallbackVideo = document.createElement('audio'); fallbackVideo.muted = true; fallbackVideo.loop = true; fallbackVideo.playsInline = true; fallbackVideo.style.position = 'fixed'; fallbackVideo.style.width = '1px'; fallbackVideo.style.height = '1px'; fallbackVideo.style.opacity = '0'; fallbackVideo.style.pointerEvents = 'none'; document.body.appendChild(fallbackVideo); fallbackVideo.src = 'data:audio/wav;base64,UklGRgAAAAAA'; fallbackVideo.play().catch(()=> {});
} if (cb) {
cb.addEventListener('change', async (e)=> {
const on = !!e.target.checked; settings.karaoke.aod = on; persistSettings(); if (on) await requestWL(); else await releaseWL();
});
} document.addEventListener('visibilitychange',
async ()=> {
if (document.visibilityState === 'visible' && cb && cb.checked) {
await requestWL();
}
});
})();
})(); (function() {
const fsBtn = document.getElementById('btnKaroFS'); const win = document.getElementById('winKaro'); function toggleFS() {
if (!document.fullscreenElement) {
win.requestFullscreen?.();
} else {
document.exitFullscreen?.();
}
} fsBtn.addEventListener('click', toggleFS); document.addEventListener('fullscreenchange', ()=> {
const active = !!document.fullscreenElement; fsBtn.textContent = active? '‚§¢': '‚õ∂'; fsBtn.setAttribute('aria-pressed', active? 'true': 'false');
});
})(); document.getElementById('density').value = settings.ui.density; applyDensity(settings.ui.density); fit16Active = settings.ui.fit16; document.getElementById('fit16').checked = settings.ui.fit16; if (fit16Active) autoFit16(); document.getElementById('palette').value = settings.ui.palette; palette = settings.ui.palette; document.getElementById('preset').value = settings.ui.preset; applyPreset(settings.ui.preset); document.getElementById('limStr').value = settings.audio.limiter; onLimiter(); document.getElementById('notch').value = settings.audio.notch; onNotch(); document.getElementById('contMode').value = settings.ui.contMode; contMode = settings.ui.contMode; document.getElementById('autoAssign').value = settings.ui.autoAssign? '1': '0'; autoAssign = settings.ui.autoAssign; document.getElementById('autoRecovery').value = settings.ui.autoRecovery? '1': '0'; autoRecovery = settings.ui.autoRecovery; document.getElementById('solfEnable').checked = settings.audio.solfEnable; solfEnable = settings.audio.solfEnable; document.getElementById('solfType').value = settings.audio.solfType; solfType = settings.audio.solfType; document.getElementById('solfFreq').value = String(settings.audio.solfFreq); solfFreq = settings.audio.solfFreq; document.getElementById('solfLevel').value = String(settings.audio.solfLevel); document.getElementById('tuneEnable').checked = settings.audio.tuneEnable; tuneEnable = settings.audio.tuneEnable; document.getElementById('tuneFreq').value = String(settings.audio.tuneFreq); tuneFreq = settings.audio.tuneFreq; applySavedWindows(); buildMixerOnce();

// ADD: init audio-only state
const audioOnlyCB = document.getElementById('audioOnly');
if (audioOnlyCB) {
audioOnlyCB.addEventListener('change', (e)=> {
settings.ui.audioOnly = !!e.target.checked;
persistSettings();
applyAudioOnlyUI(settings.ui.audioOnly);
log('Audio‚Äëonly ' + (settings.ui.audioOnly ? 'ON': 'OFF'));
});
audioOnlyCB.checked = !!settings.ui.audioOnly;
applyAudioOnlyUI(!!settings.ui.audioOnly);
}
}
//buildUI end

if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', bindUI);
} else {
bindUI();
}




function applySavedWindows() {
if (!settings.windows) return; for (const id in settings.windows) {
const w = document.getElementById(id); if (!w) continue; const st = settings.windows[id]; if (st.left) w.style.left = st.left; if (st.top) w.style.top = st.top; if (st.width) w.style.width = st.width; if (st.display) w.style.display = st.display;
}
}
let fit16Active = true; function applyDensity(mode) {
const body = document.body; body.classList.remove('density-ultra', 'density-compact', 'density-normal'); body.classList.add('density-'+mode); if (fit16Active) autoFit16();
}
function autoFit16() {
const grid = document.getElementById('chGridVert'); const gap = parseInt(getComputedStyle(grid).gap) || 6; const W = window.innerWidth - 16; const min = 48; const col = Math.max(min, Math.floor((W - gap*(16-1))/16)); document.documentElement.style.setProperty('--stripW', col+'px'); const meterH = Math.max(56, Math.floor(col*1.05)); document.documentElement.style.setProperty('--meterH', meterH+'px'); document.documentElement.style.setProperty('--meterW', Math.max(4, Math.floor(col*0.10))+'px');
}

function initAudioChain() {
  masterIn = audioCtx.createGain();
  masterIn.gain.value = 1.0;

  // EQ bands
  eqBands = EQ_FREQS.map((f, idx) => {
    const b = audioCtx.createBiquadFilter();
    b.type = (idx === 0 ? 'lowshelf' : (idx === 9 ? 'highshelf' : 'peaking'));
    if (b.type === 'peaking') b.Q.value = 1.0;
    b.frequency.value = f;
    const val = parseFloat(document.getElementById('eq10_' + idx)?.value || '0');
    b.gain.value = val;
    return b;
  });

  // Filters & limiter
  hpf = audioCtx.createBiquadFilter();  hpf.type = 'highpass'; hpf.frequency.value = 28;
  notch = audioCtx.createBiquadFilter(); notch.type = 'notch';
  const notchSel = parseFloat(document.getElementById('notch')?.value || '0');
  notch.frequency.value = (notchSel > 0 ? notchSel : 1000);
  notch.Q.value         = (notchSel > 0 ? 28      : 0.0001);

  clip = audioCtx.createWaveShaper();
  
  clip.curve = makeSoftClipCurve(parseFloat(document.getElementById('limStr')?.value || '0.80'), 8192, 1.08);
clip.oversample = '4x';

  // Analyser + transport + destinations
  analyser   = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  analyser.smoothingTimeConstant = 0.85;

  transport  = audioCtx.createGain();
  transport.gain.value = 1.0;

  masterOut  = audioCtx.destination;
  mediaDest  = audioCtx.createMediaStreamDestination();

  // Chain: masterIn ‚Üí EQ ‚Üí HPF ‚Üí Notch ‚Üí Clip ‚Üí (analyser?) ‚Üí transport ‚Üí outputs
  let node = masterIn;
  for (const b of eqBands) {
    node.connect(b);
    node = b;
  }
  node.connect(hpf).connect(notch).connect(clip);

  // === IMPORTANT: only now set flags and wire final stage ===
  drawVizEnabled   = !settings.ui.audioOnly;
  goertzelEnabled  = !settings.ui.audioOnly;
  analyserBypassed = !!settings.ui.audioOnly;

  try {
    wireFinalStage(!analyserBypassed); // clip ‚Üí analyser ‚Üí transport OR clip ‚Üí transport
  } catch (e) {
    try { log('Wire error: ' + (e.message || e)); } catch (_) {}
    // Fallback: hard-connect clip ‚Üí transport ‚Üí outputs to avoid init failure
    try {
      clip.connect(transport);
      transport.connect(masterOut);
      transport.connect(mediaDest);
    } catch (_) {}
  }

  // Solfeggio bus
  solfGainNode = audioCtx.createGain();
  solfGainNode.gain.value = parseFloat(document.getElementById('solfLevel')?.value || '0.12');
  solfGainNode.connect(transport);

  // Channel gains
  for (let ch = 0; ch < 16; ch++) {
    const g = audioCtx.createGain();
    g.gain.value = 0.0;
    channels[ch].gain = g;
    g.connect(masterIn);
  }

  // Viz buffers
  setupVizCanvas();

  // Schedule loops only if enabled
  if (drawVizEnabled)  { _vizRAF      = requestAnimationFrame(drawWave); }
  updateRetune();
  if (goertzelEnabled) { _goertzelRAF = requestAnimationFrame(goertzelDetectLoop); }
}


function setupVizCanvas() {
vizCanvas = document.getElementById('mainViz'); if (!vizCanvas) return; const dpr = window.devicePixelRatio || 1; const cssW = vizCanvas.clientWidth || window.innerWidth; const cssH = vizCanvas.clientHeight || 84; vizCanvas.width = Math.floor(cssW*dpr); vizCanvas.height = Math.floor(cssH*dpr); vizCtx = vizCanvas.getContext('2d'); vizCtx.setTransform(dpr, 0, 0, dpr, 0, 0); vizBuffer = new Uint8Array(analyser? analyser.fftSize: 2048);
// NEW: float time-domain buffer for Goertzel
vizBufferF = new Float32Array(analyser ? analyser.fftSize: 2048);
}



function drawWave() {
if (!vizCtx) {
requestAnimationFrame(drawWave); return;
}
if (!drawVizEnabled) {
return;
} // gate in audio-only
const W = vizCanvas.width/(window.devicePixelRatio || 1),
H = vizCanvas.height/(window.devicePixelRatio || 1);
vizCtx.fillStyle = '#0a1220'; vizCtx.fillRect(0, 0, W, H);
vizCtx.strokeStyle = '#00b3ff'; vizCtx.lineWidth = 1.4; vizCtx.beginPath();
if (analyser) {
analyser.getByteTimeDomainData(vizBuffer); const step = (vizBuffer.length-1) / (W-2); for (let x = 0; x < W; x++) {
const idx = Math.min(vizBuffer.length-1, Math.floor(x*step)); const v = (vizBuffer[idx]-128)/128; const y = H*0.5 + v*(H*0.42); if (x === 0) vizCtx.moveTo(x+1, y); else vizCtx.lineTo(x+1, y);
}
} else {
vizCtx.moveTo(0, H*0.5); vizCtx.lineTo(W, H*0.5);
}
vizCtx.stroke(); vizCtx.strokeStyle = '#24344e'; vizCtx.lineWidth = 1; vizCtx.beginPath(); vizCtx.moveTo(0, H*0.5); vizCtx.lineTo(W, H*0.5); vizCtx.stroke();
if (drawVizEnabled) requestAnimationFrame(drawWave);
}

//===Goertzel single-bin detector (power at target frequency)===
function goertzelPower(samples, sampleRate, targetHz) {
const N = samples.length;
if (!N || !sampleRate || !isFinite(sampleRate) || !isFinite(targetHz)) return 0;

const k = Math.round((targetHz / sampleRate) * N);
const w = (2*Math.PI*k)/N;
const cosW = Math.cos(w),
sinW = Math.sin(w);

let s_prev = 0.0,
s_prev2 = 0.0;
for (let i = 0; i < N; i++) {
const x = samples[i];
const s = x + 2*cosW*s_prev - s_prev2;
s_prev2 = s_prev;
s_prev = s;
}

const real = s_prev - s_prev2*cosW;
const imag = s_prev2*sinW;
const power = (real*real + imag*imag) / N; // normalized
return power;
}

function goertzelDetectLoop() {
if (!goertzelEnabled) {
return;
} // gate in audio-only
try {
if (!audioCtx || !analyser || !vizBufferF) {
if (goertzelEnabled) _goertzelRAF = requestAnimationFrame(goertzelDetectLoop);
return;
}

analyser.getFloatTimeDomainData(vizBufferF);

if (solfEnable) {
const sr = audioCtx.sampleRate || 48000;
const targ = solfFreq || 528;
const p = goertzelPower(vizBufferF, sr, targ);
const db = 10 * Math.log10(Math.max(1e-12, p));
const chip = document.getElementById('solfDetect');
if (chip) {

const levelColor = (db > -20) ? '#17c964': (db > -30) ? '#f5a524': '#9fbad1';
chip.textContent = ''; // no text
chip.style.color = ''; // ignore text color
chip.style.backgroundColor = levelColor; // dot color

}
} else {


const chipS = document.getElementById('solfDetect');
if (chipS) {
chipS.textContent = '';
chipS.style.backgroundColor = '#9fbad1';
}

}


// Retune detection
if (tuneEnable) {
const sr = audioCtx.sampleRate || 48000;
const targ = tuneFreq || 528;
const p = goertzelPower(vizBufferF, sr, targ);
const db = 10 * Math.log10(Math.max(1e-12, p));
const chip = document.getElementById('tuneDetect');
if (chip) {

const levelColor = (db > -20) ? '#17c964': (db > -30) ? '#f5a524': '#9fbad1';
chip.textContent = ''; // no text
chip.style.color = ''; // ignore text color
chip.style.backgroundColor = levelColor; // dot color

}
} else {

const chip = document.getElementById('tuneDetect');
if (chip) {
chip.textContent = '';
chip.style.backgroundColor = '#9fbad1';
}

}
}catch(e) {
try {
log('Goertzel error: ' + (e.message || e));
}catch(_) {}
}

if (goertzelEnabled) _goertzelRAF = requestAnimationFrame(goertzelDetectLoop);
}

async function initAudio() {
if (!audioCtx) {
audioCtx = new (window.AudioContext || window.webkitAudioContext)(); initAudioChain(); requestAnimationFrame(chRenderLoop); requestAnimationFrame(voiceWatchdogLoop);
} try {
await audioCtx.resume();
}catch(e) {} log('Audio ready.'); document.getElementById('btnStop').disabled = true; document.getElementById('btnPlay').disabled = !(playlist.length > 0 && currentIndex >= 0); document.getElementById('btnPanic').disabled = false;
// Update other buttons
  document.getElementById('btnStop').disabled = true;
  document.getElementById('btnPlay').disabled = !(playlist.length > 0 && currentIndex >= 0);
  document.getElementById('btnPanic').disabled = false;
  document.getElementById('btnInit').style.display = 'none';

 
}




function stopSolfOscs() {
const t = audioCtx?.currentTime || 0; const list = [solfOscL,
solfOscR]; for (const o of list) {
try {
o && o.stop(t+0.01); o && o.disconnect?.();
}catch(e) {} if (o) {
o.started = false; o._connected = false;
}
} if (solfPanL) try {
solfPanL.disconnect();
}catch(e) {} if (solfPanR) try {
solfPanR.disconnect();
}catch(e) {} solfOscL = null; solfOscR = null; solfPanL = null; solfPanR = null;
}
function updateSolfeggio(forceRebuild = false) {
if (!audioCtx || !solfGainNode) return; const t = audioCtx.currentTime; if (!solfEnable) {
stopSolfOscs(); try {
solfGainNode.gain.setTargetAtTime(0.0, t, 0.10);
}catch(e) {} return;
} if (forceRebuild) {
stopSolfOscs();
} const lvl = parseFloat(document.getElementById('solfLevel')?.value || '0.12'); try {
solfGainNode.gain.setTargetAtTime(lvl, t, 0.08);
}catch(e) {} if (solfType === 'binaural') {
if (!solfOscL) {
solfOscL = audioCtx.createOscillator(); solfOscL.type = 'sine';
} if (!solfOscR) {
solfOscR = audioCtx.createOscillator(); solfOscR.type = 'sine';
} if (!solfPanL && audioCtx.createStereoPanner) {
solfPanL = audioCtx.createStereoPanner(); solfPanL.pan.value=-1;
} if (!solfPanR && audioCtx.createStereoPanner) {
solfPanR = audioCtx.createStereoPanner(); solfPanR.pan.value=+1;
} const delta = BEAT_DELTA_HZ; const fL = Math.max(20, solfFreq - delta/2); const fR = Math.max(20, solfFreq + delta/2); try {
solfOscL.frequency.setValueAtTime(fL, t); solfOscR.frequency.setValueAtTime(fR, t);
}catch(e) {} if (!solfOscL._connected) {
try {
solfOscL.connect(solfPanL || solfGainNode); if (solfPanL) solfPanL.connect(solfGainNode); solfOscL._connected = true;
}catch(e) {}
} if (!solfOscR._connected) {
try {
solfOscR.connect(solfPanR || solfGainNode); if (solfPanR) solfPanR.connect(solfGainNode); solfOscR._connected = true;
}catch(e) {}
} if (!solfOscL.started) {
try {
solfOscL.start(t+0.01); solfOscL.started = true;
}catch(e) {}
} if (!solfOscR.started) {
try {
solfOscR.start(t+0.01); solfOscR.started = true;
}catch(e) {}
}
} else {
if (!solfOscL) {
solfOscL = audioCtx.createOscillator(); solfOscL.type = 'sine';
} try {
solfOscL.frequency.setValueAtTime(Math.max(20, solfFreq), t);
}catch(e) {} if (!solfOscL._connected) {
try {
solfOscL.connect(solfGainNode); solfOscL._connected = true;
}catch(e) {}
} if (!solfOscL.started) {
try {
solfOscL.start(t+0.01); solfOscL.started = true;
}catch(e) {}
} if (solfOscR) {
try {
solfOscR.stop(t+0.01); solfOscR.disconnect();
}catch(e) {} solfOscR = null;
} if (solfPanL) {
try {
solfPanL.disconnect();
}catch(e) {} solfPanL = null;
} if (solfPanR) {
try {
solfPanR.disconnect();
}catch(e) {} solfPanR = null;
}
}
}

function midiToFreq(m) {
return 440*Math.pow(2, (m-69)/12);
}
function nearestMidiNoteForFreq(f) {
return Math.max(0, Math.min(127, Math.round(69 + 12*Math.log2(f/440))));
}
function updateRetune() {
if (!audioCtx) return; if (!tuneEnable) {
globalDetuneRatio = 1.0; return;
} const target = tuneFreq || 528; const midi = nearestMidiNoteForFreq(target); const std = midiToFreq(midi); globalDetuneRatio = Math.max(0.25, Math.min(4.0, target / std)); log(`Retune: target ${target} Hz ~ MIDI ${midi} (${std.toFixed(2)} Hz) ‚Üí ratio ${globalDetuneRatio.toFixed(6)}`);
}

function startRecording(mode) {
if (!audioCtx) {
log('Init Audio first'); return;
} if (!mediaDest) {
log('Recording not available'); return;
} if (mediaRecorder && mediaRecorder.state === 'recording') {
log('Already recording'); return;
} recChunks = []; const preferred = (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) ? 'audio/webm;codecs=opus': 'audio/webm'; try {
mediaRecorder = new MediaRecorder(mediaDest.stream, {
mimeType: preferred
});
}catch(e) {
log('Recorder init failed: '+(e.message || e)); return;
} mediaRecorder.ondataavailable = (e)=> {
if (e.data && e.data.size > 0) recChunks.push(e.data);
}; mediaRecorder.onstop = ()=> {
const blob = new Blob(recChunks, {
type: preferred
}); const url = URL.createObjectURL(blob); const dl = document.getElementById('recDownload'); const name = 'mix_'+new Date().toISOString().replace(/[:.]/g, '-')+'.webm'; dl.href = url; dl.download = name; dl.style.display = 'inline-block'; log('Recording ready: '+name); setTimeout(()=> {
try {
URL.revokeObjectURL(url);
}catch(_) {}
}, 5*60*1000);
}; mediaRecorder.start(); document.getElementById('btnRecStop').disabled = false; log('‚è∫ Recording '+(mode === 'restart'?'(restart)': '(current)')); if (mode === 'restart') {
stopPlayback(); ensureParsed().then((ok)=> {
if (ok) {
startPlayback(true);
}
});
}
}
function stopRecording() {
if (mediaRecorder && mediaRecorder.state === 'recording') {
try {
mediaRecorder.stop();
}catch(e) {}
} document.getElementById('btnRecStop').disabled = true;
}
function onLimiter() {
  if (!clip) return;
  const k = parseFloat(document.getElementById('limStr').value || '0.80');
  clip.curve = makeSoftClipCurve(k, 8192, 1.08);
  log('Limiter (soft clip) drive k=' + k.toFixed(2));
}
function onNotch() {
if (!notch) return; const v = parseFloat(document.getElementById('notch').value || '0'); notch.frequency.value = (v > 0? v: 1000); notch.Q.value = (v > 0? 28: 0.0001); log('Notch '+(v > 0? v+' Hz': 'Off'));
}
function onEq10Slider() {
if (!eqBands?.length) return; for (let i = 0; i < 10; i++) {
const v = parseFloat(document.getElementById('eq10_'+i)?.value || '0'); eqBands[i].gain.value = v;
}
}
function applyPreset(name) {
const map = {
'Flat': [0,
0,
0,
0,
0,
0,
0,
0,
0,
0],
'Warm': [3,
2,
1,
0,
-1,
-1,
-2,
-3,
-4,
-5],
'Bright': [-2,
-1,
0,
1,
2,
2,
2,
3,
4,
5],
'Vocal': [-3,
-2,
-1,
0,
1,
2,
3,
2,
1,
0],
'BassBoost': [6,
4,
2,
0,
-1,
-2,
-2,
-2,
-3,
-4],
'BassStrong': [8,
6,
4,
1,
0,
-1,
-2,
-3,
-4,
-5]
}[name] || [0,
0,
0,
0,
0,
0,
0,
0,
0,
0]; for (let i = 0; i < 10; i++) {
const el = document.getElementById('eq10_'+i); if (el) {
el.value = map[i];
}
} onEq10Slider(); log('Preset '+name);
}

function applyCalm() {
applyPreset('Warm'); const lim = document.getElementById('limStr'); if (lim) {
lim.value = 0.78; settings.audio.limiter = 0.78; persistSettings();
} onLimiter(); log('Calm applied');
}

async function onAddFiles(e) {
const files = Array.from(e.target.files || []); if (!files?.length) {
log('No files from picker. Choose files stored "On this device".'); return;
} addFiles(files);
}
function addFiles(files) {
const list = Array.from(files || []); for (const f of list) {
const name = f.name || 'file.mid'; playlist.push({
name, file: f, parsed: false, tempo: null, events: null, lyrics: null
});
} updatePlaylistUI(); if (currentIndex===-1) {
selectTrack(0);
} document.getElementById('btnPlay').disabled = false; document.getElementById('btnStop').disabled = false; log('Files added: '+list.length+'.');
}

function updatePlaylistUI() {
const list = document.getElementById('plList');
list.innerHTML = '';

if (playlist.length === 0) {
list.innerHTML = '<div class="plItem">(No items)</div>';
return;
}

playlist.forEach((t, i)=> {
const row = document.createElement('div');
row.className = 'plItem' + (i === currentIndex ? ' active': '');
row.dataset.index = i;
row.title = 'Tap to select';

const label = document.createElement('span');
label.textContent = (i+1) + '. ' + t.name + (t.parsed ? '': ' (noOb)');

const playBtn = document.createElement('button');
playBtn.className = 'btn';
playBtn.type = 'button';
playBtn.textContent = '‚ñ∂';
playBtn.title = 'Play';

playBtn.addEventListener('click', async (ev)=> {
ev.stopPropagation();
selectTrack(i);
const mainPlay = document.getElementById('btnPlay');
if (mainPlay && !mainPlay.disabled) {
mainPlay.click();
} else {
if (!audioCtx) await initAudio();
await startPlayback(true);
}
const winPl = document.getElementById('winPlaylist');
const winKar = document.getElementById('winKaro');
if (winPl) winPl.style.display = 'none';
if (winKar) {
winKar.style.display = 'block';
winKar.style.zIndex = (++zCounter).toString();
}
});

row.addEventListener('click',
()=> {
selectTrack(i);
},
{
passive: true
});

row.appendChild(label);
row.appendChild(playBtn);
list.appendChild(row);
});

document.getElementById('btnStop').disabled = (playlist.length === 0);
}




function resetStateForNewTrack() {
for (let ch = 0; ch < 16; ch++) {
chAct[ch].level = 0; chAct[ch].last = 0; chSeen[ch] = false; channels[ch].prog = null;
} seq.ptr = 0; seq.startTick = 0; seq.running = false; if (seq.timer) {
clearInterval(seq.timer); seq.timer = null;
} refreshMixerCounters(true); updateMixerMeters();
}

function selectTrack(i) {
if (i < 0 || i >= playlist.length) return; currentIndex = i; hardResetAudio(); resetStateForNewTrack();
if (solfEnable && solfGainNode) {
try {
updateSolfeggio(true);
} catch(e) {}
}
if (!audioOnly) {
try {
LyricsLive.rebuild(); Karo.rebuild();
}catch(_) {}
}
const song = playlist[i]; _tempo = song.tempo; seq.events = song.events || []; updatePlaylistUI(); document.getElementById('btnPlay').disabled = false; document.getElementById('btnStop').disabled = false; log('Selected: '+song.name+(song.parsed?' ‚Ä¢ parsed': ' ‚Ä¢ lazy')); document.getElementById('currentTitle').textContent = playlist[i].name || '(Unknown title)';

if (song.lyrics) {
lyrics.json = song.lyrics; renderLyricsStatic(); LyricsLive.rebuild(); Karo.rebuild();
}
}

function tickToSec(t) {
return _tempo ? _tempo.tickToSec(t): (t/480)*0.5;
}


// Choose dominant meta type per song: prefer 0x05 > 0x01 > 0x03 on ties.
function pickDominantLyricType(metaEvs) {
  const counts = { 0x05: 0, 0x01: 0, 0x03: 0 };
  for (const e of metaEvs || []) {
    if (!e || e.kind !== 'meta') continue;
    const t = e.type | 0;
    if (t !== 0x05 && t !== 0x01 && t !== 0x03) continue;
    counts[t] = (counts[t] || 0) + 1;
  }
  const order = [0x05, 0x01, 0x03];
  let best = 0x05;
  for (const t of order) {
    if ((counts[t] || 0) > (counts[best] || 0)) best = t;
  }
  return best;
}


async function ensureParsed() {
  const song = playlist[currentIndex];
  if (!song) return false;
  if (song.parsed) return true;

  try {
    const buf = await song.file.arrayBuffer();
    const u8 = new Uint8Array(buf);
    const smf   = parseSMF(u8);
    const tempo = buildTempoMap(smf);
    const evs   = collectEvents(smf);
    const metaEvs = collectMetaLyrics(smf);


// ==== RAW LYRICS (source) ‚Äî END ====
// ==== RAW LYRICS (source) ====
try {
  for (const e of metaEvs) {
    if (!e || e.kind !== 'meta') continue;
    if (e.type !== 0x05 && e.type !== 0x01 && e.type !== 0x03) continue;

    const sec = tempo.tickToSec(e.tick).toFixed(3);
    // Decode using TextDecoder directly
    let txt = '';
    try {
      txt = new TextDecoder('utf-8').decode(e.data);
      if (/\uFFFD/.test(txt)) {
        txt = new TextDecoder('latin1').decode(e.data);
      }
    } catch(_) {
      for (let i = 0; i < e.data.length; i++) txt += String.fromCharCode(e.data[i]);
    }
    txt = txt.replace(/\u0000/g, ''); // strip NULs

    log(`[${sec}s] type=0x${e.type.toString(16)} "${txt}"`);
  }
} catch(err) {
  log('RAW LYRICS log error: ' + (err.message || err));
}

    rebuildLyricSourceOptions(metaEvs);
    song.tempo  = tempo;
    song.events = evs;
    song.parsed = true;
    _tempo = tempo;
    seq.events = evs;

    // === Source selection: auto or fixed ===
    const uiSrc = (lyrics.source || settings.lyrics.source || 'auto'); // allow 'auto', '05', '01', '03', or combos
    let allowPrimary;

    if (uiSrc === '05')      allowPrimary = [0x05];
    else if (uiSrc === '01') allowPrimary = [0x01];
    else if (uiSrc === '03') allowPrimary = [0x03];
    else {
      // Any other value (including combos like '01+05+03') ‚Üí auto single-source
      const dominant = pickDominantLyricType(metaEvs);
      allowPrimary = [dominant];
      log(`Lyric source AUTO ‚Üí using 0x${dominant.toString(16)} only (no mixing).`);
    }

    // === Always use auto encoding ===
    const optsPrimary = {
      preserveSpaces: lyrics.preserveSpaces,
      splitOnSlash:   lyrics.splitOnSlash,
      enc:            'auto',        // <=== always auto detect
      skipHeaders:    true,
      allowAtZero:    false,
      coalesceNear:   0.015,
      dedupeAdjacent: false,         // keep legit repeats ("la la")
      dedupeSameTime: true,          // safe in-line duplicates only
      compressSpaces: false,
      splitSlashMode: 'smart'
    };

    let json = buildLyricsJSON(metaEvs, tempo.tickToSec, allowPrimary, optsPrimary);

    // === Fallback only if zero lines (still single-source; relax filters) ===
    if (!json || !Array.isArray(json.lines) || json.lines.length === 0) {
      const optsFallback = {
        preserveSpaces: lyrics.preserveSpaces,
        splitOnSlash:   lyrics.splitOnSlash,
        enc:            'auto',      // still auto
        skipHeaders:    false,       // allow lyrics embedded as "header"
        allowAtZero:    true,        // accept t==0 events
        coalesceNear:   0.020,
        dedupeAdjacent: false,
        dedupeSameTime: true,
        compressSpaces: false,
        splitSlashMode: 'smart'
      };
      json = buildLyricsJSON(metaEvs, tempo.tickToSec, allowPrimary, optsFallback);
      if (Array.isArray(json?.lines) && json.lines.length > 0) {
        log('Lyrics fallback applied (single-source, enc=auto, allowAtZero).');
      }
    }

    song.lyrics = json;
    lyrics.json = json;

    // Show "No lyrics" truthfully if none
    const hasLines = Array.isArray(lyrics.json?.lines) && lyrics.json.lines.length > 0;
    log('Parsed lyric lines: ' + (hasLines ? lyrics.json.lines.length : 0));
    if (!hasLines) {
      log('Lyrics: none (this MIDI has no lyric meta, or filtered by source).');
    }

    return true;
  } catch (err) {
    log('Parse error (' + song.name + '): ' + (err.message || err));
    return false;
  }
}
¬†

async function startPlayback(withGap = false) {
if (!audioCtx) {
log('Init Audio first'); return;
} const ok = await ensureParsed(); if (!ok || !seq.events?.length) {
log('No events to play'); return;
} try {
await audioCtx.resume();
}catch(e) {} const t0 = audioCtx.currentTime; const startAt = t0 + (withGap? GAP_SEC: 0.06); try {
transport.gain.cancelScheduledValues(t0); transport.gain.setValueAtTime(0.0, t0); transport.gain.setTargetAtTime(1.0, startAt, 0.015);
}catch(e) {} for (let ch = 0; ch < 16; ch++) {
const g = channels[ch].gain; if (g) {
try {
g.gain.setValueAtTime(0.0, t0); g.gain.setTargetAtTime(channels[ch].baseGain*channels[ch].expr, startAt, 0.015);
}catch(e) {}
}
} updateMixGains(true); seq.startTime = startAt; seq.ptr = 0; seq.running = true; if (seq.timer) clearInterval(seq.timer); seq.timer = setInterval(scheduleTick, seq.lookAhead*1000); log('‚ñ∂ '+(playlist[currentIndex]?.name || '')); lyrics.startAt = startAt; if (!audioOnly) {
LyricsLive.rebuild(); LyricsLive.start(); Karo.rebuild(); Karo.start(lyrics.startAt);
}
}

function stopPlayback() {
if (seq.timer) clearInterval(seq.timer); seq.timer = null; seq.running = false; try {
transport.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.02);
}catch(e) {} hardResetAudio(); log('‚èπ Stopped'); try {
LyricsLive && LyricsLive.stop();
}catch(_) {} try {
Karo && Karo.stop();
}catch(_) {}
}
function panicAll() {
hardResetAudio(); log('‚õë Panic: all voices killed and channels muted.'); try {
LyricsLive && LyricsLive.stop();
}catch(_) {} try {
Karo && Karo.stop();
}catch(_) {}
}
function scheduleTick() {
const horizon = audioCtx.currentTime - seq.startTime + seq.scheduleAhead; while (seq.ptr < seq.events.length) {
const ev = seq.events[seq.ptr]; const when = seq.startTime + tickToSec(ev.tick - seq.startTick); if ((when - audioCtx.currentTime) > seq.scheduleAhead) break; dispatchMidi(ev, when); seq.ptr++;
} if (seq.ptr >= seq.events.length) {
clearInterval(seq.timer); seq.timer = null; seq.running = false; log('‚úÖ Finished'); LyricsLive.stop(); Karo.stop(); if (contMode === 'next') {
const next = currentIndex+1; if (next < playlist.length) {
selectTrack(next); startPlayback(true);
}
} else if (contMode === 'loop') {
selectTrack(currentIndex); startPlayback(true);
}
}
}

//instrument

function anySolo() {
for (let ch = 0; ch < 16; ch++) {
if (channels[ch].solo) return true;
} return false;
}
function channelTargetFactor(ch) {
const st = channels[ch]; const soloed = anySolo(); if (soloed) {
return st.solo ? 1.0: MUTE_FACTOR;
} else {
return st.mute ? MUTE_FACTOR: 1.0;
}
}
function updateMixGains(hard = false) {
if (!audioCtx) return; const now = audioCtx.currentTime; for (let ch = 0; ch < 16; ch++) {
const st = channels[ch]; const g = st.gain?.gain; if (!g) continue; const base = st.baseGain * st.expr; const factor = channelTargetFactor(ch); const target = base * factor; try {
if (hard) {
g.cancelScheduledValues(now); g.setValueAtTime(target, now);
} else {
g.setTargetAtTime(target, now, 0.03);
}
}catch(e) {}
}
}

const noteStartTimes = Array(16).fill(null).map(()=>new Map()); const stopRegistry = Array(16).fill(null).map(()=>new Map());

function gmToInst(prog, palette) {
const p = prog|0; const cat = (p <= 7)?'piano': (p <= 15)?'chrom': (p <= 23)?'organ': (p <= 31)?'guitar': (p <= 39)?'bass': (p <= 47)?'strings': (p <= 55)?'ens': (p <= 63)?'brass': (p <= 71)?'reed': (p <= 79)?'pipe': (p <= 87)?'lead': (p <= 95)?'pad': (p <= 103)?'fx': (p <= 111)?'ethnic': (p <= 119)?'perc': 'sfx'; const mapClassic = {
piano: 'pianoLite',
chrom: 'fm',
organ: 'square',
guitar: 'guitar',
bass: 'deepBass',
strings: 'triangle',
ens: 'saw',
brass: 'square',
reed: 'triangle',
pipe: 'triangle',
lead: 'saw',
pad: 'square',
fx: 'fm',
ethnic: 'triangle',
perc: 'fm',
sfx: 'fm'
}; const mapEDM = {
piano: 'pianoLite',
chrom: 'fm',
organ: 'square',
guitar: 'guitar',
bass: 'deepBass',
strings: 'saw',
ens: 'saw',
brass: 'square',
reed: 'triangle',
pipe: 'triangle',
lead: 'saw',
pad: 'saw',
fx: 'fm',
ethnic: 'triangle',
perc: 'fm',
sfx: 'fm'
}; const mapChip = {
piano: 'pianoLite',
chrom: 'square',
organ: 'square',
guitar: 'guitar',
bass: 'deepBass',
strings: 'triangle',
ens: 'square',
brass: 'square',
reed: 'square',
pipe: 'square',
lead: 'square',
pad: 'square',
fx: 'square',
ethnic: 'square',
perc: 'square',
sfx: 'square'
}; const table = palette === 'edm'? mapEDM: palette === 'chip'? mapChip: mapClassic; return table[cat] || 'triangle';
}

function maybeAutoAssign(ch) {
const st = channels[ch]; if (ch === 9) return; if (!autoAssign) return; if (st.locked) return; const desired = (st.prog != null) ? gmToInst(st.prog, palette): chanFallbackInst(ch); if (st.inst == null || st.inst === 'triangle' || st.inst === 'saw' || st.inst === 'square') {
st.inst = desired;
}
}

// Neutral placeholders are considered "not yet assigned"
const PLACEHOLDERS = new Set(['triangle', 'square', 'saw']);

// Manual/assigned ‚Üí GM Program ‚Üí Channel fallback (only when neutral and no program)
function resolveInstrument(ch) {
  const st = channels[ch];
  if (!st) return 'triangle'; // safety

  // 1) Manual / already-concrete instrument wins
  if (st.inst && !PLACEHOLDERS.has(st.inst)) return st.inst;

  // 2) GM Program mapping (if present)
  if (st.prog != null) return gmToInst(st.prog, palette);

  // 3) Passive channel fallback (only when neutral / no program)
  return chanFallbackInst(ch);
}
¬†

function dispatchMidi(ev, when) {
  const ch = (ev.ch | 0) || 0;
  const st = channels[ch];
  if (!st) return;

  // Prefer musical event timestamp; fall back to current time
  const eventTime = (when ?? (audioCtx?.currentTime ?? 0));

  // Ensure per-channel maps/sets exist (if you use sustain logic later)
  noteStartTimes[ch] ??= new Map();

  switch (ev.type) {

    case 'noteOn': {
      const note = ev.note | 0;
      const vel = ev.vel | 0;

      if (vel > 0) {
        if (antiBeep && vel < 3) break;

        chAct[ch].level = Math.max(chAct[ch].level, vel / 127);
        chAct[ch].last = eventTime;
        chSeen[ch] = true;

        channels[ch].lastNote = midiToName(note);
        
        if (titleBadges && titleBadges[ch]) {
          titleBadges[ch].textContent = instSymbol(channels[ch].inst);
        }

        noteStartTimes[ch].set(note, eventTime);

        if (ch === 9) {
          drumLiteVoice(ch, note, vel, eventTime, st);
        } else {
          simpleVoiceDispatch(ch, note, vel, eventTime);
        }
      } else {
        // Velocity 0 Note On == Note Off (spec-compliant)
        const started = noteStartTimes[ch].get(note);
        if (started != null) {
          const minMs = (ch === 9 ? MIN_NOTE_MS_DRUMS : MIN_NOTE_MS_MELODY);
          const minDur = minMs / 1000;
          const plannedStop = Math.max(eventTime, started + minDur);
          scheduleStop(ch, note, plannedStop);
          noteStartTimes[ch].delete(note);
        }
      }
      break;
    }

    case 'noteOff': {
      const note = ev.note | 0;
      const started = noteStartTimes[ch].get(note);
      if (started != null) {
        const minMs = (ch === 9 ? MIN_NOTE_MS_DRUMS : MIN_NOTE_MS_MELODY);
        const minDur = minMs / 1000;
        const plannedStop = Math.max(eventTime, started + minDur);
        scheduleStop(ch, note, plannedStop);
        noteStartTimes[ch].delete(note);
      }
      break;
    }

    case 'cc': {
      const cc = ev.cc | 0;
      const val = ev.value | 0;

      chAct[ch].last = eventTime;
      chSeen[ch] = true;

      if (cc === 7) {                 // Channel Volume
        st.baseGain = val / 127;
        updateMixGains();

      } else if (cc === 10) {         // Pan
        const pan = (val - 64) / 64; // [-1 .. +1]
        if (!st.pan && audioCtx?.createStereoPanner) {
          st.pan = audioCtx.createStereoPanner();
          st.pan.pan.value = 0;
          st.pan.connect(st.gain || masterIn);
        }
        if (st.pan) {
          st.pan.pan.value = Math.max(-1, Math.min(1, pan));
        }

      } else if (cc === 11) {         // Expression
        st.expr = val / 127;
        updateMixGains();

      // -------------------------------
      // RPN selection (CC101/CC100)
      // -------------------------------
      } else if (cc === 101) {        // RPN MSB
        st.rpnMsb = val;
      } else if (cc === 100) {        // RPN LSB
        st.rpnLsb = val;

        // Optional: clear Data Entry cache when a new RPN is selected
        st.dataMsb = 0;
        st.dataLsb = 0;

      // -------------------------------
      // Data Entry (CC6/CC38) for current RPN
      // -------------------------------
      } else if (cc === 6) {          // Data Entry MSB (coarse)
        st.dataMsb = val;

        // Apply if current RPN is Pitch Bend Sensitivity (0/0)
        if (st.rpnMsb === 0 && st.rpnLsb === 0) {
          const coarseSemitones = st.dataMsb;        // integer semitones
          const fineSemitones   = (st.dataLsb ?? 0) / 127; // 0..~1 semitone
          st.bendRange = Math.max(0, coarseSemitones + fineSemitones);
          // No UI update needed here; pitchbend uses st.bendRange
        }

      } else if (cc === 38) {         // Data Entry LSB (fine)
        st.dataLsb = val;

        if (st.rpnMsb === 0 && st.rpnLsb === 0) {
          const coarseSemitones = st.dataMsb ?? 0;
          const fineSemitones   = st.dataLsb / 127;
          st.bendRange = Math.max(0, coarseSemitones + fineSemitones);
        }

      // -------------------------------
      // Data Increment/Decrement (optional)
      // -------------------------------
      } else if (cc === 96) {         // Data Increment
        if (st.rpnMsb === 0 && st.rpnLsb === 0) {
          st.dataMsb = Math.min(127, (st.dataMsb ?? 0) + 1);
          const fineSemitones = (st.dataLsb ?? 0) / 127;
          st.bendRange = Math.max(0, st.dataMsb + fineSemitones);
        }

      } else if (cc === 97) {         // Data Decrement
        if (st.rpnMsb === 0 && st.rpnLsb === 0) {
          st.dataMsb = Math.max(0, (st.dataMsb ?? 0) - 1);
          const fineSemitones = (st.dataLsb ?? 0) / 127;
          st.bendRange = Math.max(0, st.dataMsb + fineSemitones);
        }

      // -------------------------------
      // Null RPN (deselect) pattern via CC101/100 to 127,127
      // Many files/devices send CC101=127, CC100=127
      // -------------------------------
      } else if (cc === 101 && val === 127) {
        st.rpnMsb = 127;
      } else if (cc === 100 && val === 127) {
        st.rpnLsb = 127;

      // -------------------------------
      // Controller reset / all notes off / all sound off (optional but useful)
      // -------------------------------
      } else if (cc === 121) {        // Reset All Controllers
        st.baseGain = 1.0;
        st.expr = 1.0;
        st.bend = 0.0;
        st.bendRange = st.bendRange ?? 2; // keep current if set
        if (st.pan) st.pan.pan.value = 0;
        updateMixGains();

      } else if (cc === 123) {        // All Notes Off
        for (const [note, started] of noteStartTimes[ch]) {
          const minMs = (ch === 9 ? MIN_NOTE_MS_DRUMS : MIN_NOTE_MS_MELODY);
          const minDur = minMs / 1000;
          const plannedStop = Math.max(eventTime, started + minDur);
          scheduleStop(ch, note, plannedStop);
        }
        noteStartTimes[ch].clear();

      } else if (cc === 120) {        // All Sound Off
        if (typeof killChannelVoices === 'function') {
          killChannelVoices(ch);
        }
        noteStartTimes[ch].clear();
      }

      break;
    }

    case 'program': {
      st.prog = ev.prog | 0;
      chAct[ch].last = eventTime;
      chSeen[ch] = true;
      maybeAutoAssign(ch);
      if (titleBadges && titleBadges[ch]) {
        titleBadges[ch].textContent = instSymbol(channels[ch].inst);
      }
      break;
    }

    case 'pitchbend': {
      // 14-bit bend: center 8192
      const bend14 = (((ev.msb | 0) << 7) | (ev.lsb | 0)) - 8192;

      // Use dynamic bend range from RPN 0/0 if set; default ¬±2
      const semitoneRange = (st.bendRange ?? 2);
      st.bend = (bend14 / 8192) * semitoneRange;

      chAct[ch].last = eventTime;
      chSeen[ch] = true;
      break;
    }
  }
}


function scheduleStop(ch, note, tStop) {
const reg = stopRegistry[ch].get(note); if (reg && reg.stop) {
try {
reg.stop(tStop);
}catch(e) {} stopRegistry[ch].delete(note);
}
}

function simpleVoiceDispatch(ch, note, vel, when) {
const st = channels[ch]; const inst = st.inst || (useTriangle?'triangle': 'saw'); if (inst === 'pianoLite') return pianoLiteVoice(ch, note, vel, when); if (inst === 'deepBass') return fretlessBassVoice(ch, note, vel, when); if (inst === 'guitar') return guitarLiteVoice(ch, note, vel, when); return simpleVoice(ch, note, vel, when);
}
function midiToName(m) {
const names = ['C',
'C#',
'D',
'D#',
'E',
'F',
'F#',
'G',
'G#',
'A',
'A#',
'B']; const n = names[m%12]; const o = Math.floor(m/12)-1; return n+o;
}
function trackVoice(node, stopAt, ch, gain) {
voices.push({
node, stopAt, ch, gain
});
}

// instrument segment here

// === VOICE HELPERS (shared, small, safe) ===================================

// Floors: prevents denormals; exponential ramps need >0
const MIN_FLOOR = 0.00012;      // matches your global usage
const SAFE_PAD_MS = 0.002;      // micro-scheduling guard

// Small vel curve curry (optional; consistent across voices)
function velCurve(vel) {
  const vlin = Math.max(1, vel) / 127;
  return Math.pow(vlin, 0.90);  // gentle curve; use 0.85 for drums
}

// Guard start-time against "start now" crackles (mobile‚Äëfriendly)
function guardStartTime(when) {
  try {
    const now = audioCtx?.currentTime ?? 0;
    return (when < now + SAFE_PAD_MS) ? now + SAFE_PAD_MS : when;
  } catch(_) { return when; }
}

// Envelope scheduling (exponential where possible for smoothness)
function applyADSR(gainParam, t0, aMs, dMs, sustain, rMs) {
  const tA = t0 + (aMs || 0);
  const tD = tA + (dMs || 0);
  // Attack
  gainParam.cancelScheduledValues(t0);
  gainParam.setValueAtTime(MIN_FLOOR, t0);
  gainParam.exponentialRampToValueAtTime(Math.max(MIN_FLOOR, sustain), tA);
  // Decay to sustain (if sustain < peak; you can set peak == sustain to skip)
  gainParam.exponentialRampToValueAtTime(Math.max(MIN_FLOOR, sustain), tD);
  // (Release applied in stop function)
}

// Gentle release (avoid pops); uses exponential down to MIN_FLOOR
function applyRelease(gainParam, tStop, rMs) {
  const tEnd = tStop + (rMs || 0.18);
  gainParam.cancelScheduledValues(tStop);
  gainParam.setValueAtTime(Math.max(MIN_FLOOR, gainParam.value || MIN_FLOOR), tStop);
  gainParam.exponentialRampToValueAtTime(MIN_FLOOR, tEnd);
  return tEnd;
}

// Connect chain helper (readable wiring)
function chain() {
  for (let i = 0; i < arguments.length - 1; i++) {
    try { arguments[i].connect(arguments[i+1]); } catch(_) {}
  }
  return arguments[arguments.length - 1];
}

// Shared noise buffer cache (reuses buffers by key: 'hammer_10ms', 'hat_80ms', etc.)
const __noiseCache = new Map();
function getNoiseBuffer(key, sr, durMs, correlation = 0.12) {
  const tag = `${key}:${sr}:${durMs}:${correlation}`;
  const found = __noiseCache.get(tag);
  if (found) return found;

  const dur = Math.max(1, Math.floor(sr * (durMs / 1000)));
  const buf = audioCtx.createBuffer(1, dur, sr);
  const d = buf.getChannelData(0);
  for (let i = 0; i < dur; i++) {
    const r = Math.random() * 2 - 1;
    d[i] = (i > 0 ? d[i - 1] * correlation + r * (1 - correlation) : r);
  }
  __noiseCache.set(tag, buf);
  return buf;
}

// Smooth choke for playing BufferSource or Oscillator
function chokeSmooth(src, when, relMs = 18 /*ms*/) {
  try {
    const t0 = guardStartTime(when);
    // If there's a gain before dest, try an exponential down; else stop quickly
    // NOTE: Most of your cached paths use Gain; if not accessible, stop with small delay.
    if (src && src.stop) src.stop(t0 + (relMs/1000));
    src.disconnect?.();
  } catch(_) {}
}
function simpleVoice(ch, note, vel, when) {
  const st = channels[ch];
  const v  = velCurve(vel);                     // gentle velocity curve
  let f    = midiToFreq(note) * Math.pow(2, (st.bend || 0)/12) * globalDetuneRatio;

  // Micro guard
  when = guardStartTime(when);

  const inst = st.inst || (useTriangle ? 'triangle' : 'saw');
  const o    = audioCtx.createOscillator();
  const amp  = audioCtx.createGain();
  const g    = amp.gain;

  // Wave selection (respect your current mapping)
  o.type = (inst === 'triangle' || inst === 'triangle_soft') ? 'triangle'
        : (inst === 'square'   ? 'square'   : 'sawtooth');
  o.frequency.value = f;

  // Filters: center BP relative to note (timbre follows pitch)
  const bp = audioCtx.createBiquadFilter();
  bp.type = 'bandpass';
  bp.Q.value = 0.9;
  bp.frequency.value = Math.max(180, Math.min(6000, f * 4));  // dynamic center

  const dc = audioCtx.createBiquadFilter();
  dc.type = 'highpass';
  dc.frequency.value = 18;           // small bump from 12Hz
  dc.Q.value = 0.707;

  // Optional stereo pan (low CPU, only if supported)
  const dest = st.pan ? st.pan : (st.gain || masterIn);
  const panOk = !!audioCtx.createStereoPanner;
  const pan = panOk ? audioCtx.createStereoPanner() : null;
  if (pan) {
    // Tiny random spread per note (¬±0.12)
    pan.pan.value = (Math.random() * 0.24) - 0.12;
  }

  // Envelope: Attack/Decay; Release at stop
  applyADSR(g, when, /*attack*/ 10/1000, /*decay*/ 120/1000, /*sustain*/ v);

  // Wiring
  if (pan) chain(o, bp, dc, amp, pan, dest);
  else     chain(o, bp, dc, amp, dest);

  // Start
  o.start(when);

  // Planned stop (musical)
  const plannedStop = when + ENV_RELEASE + 0.80;

  stopRegistry[ch].set(note, {
    stop: (tStop) => {
      // Smooth release; hard stop after release time
      const hardStop = applyRelease(g, tStop, /*release*/ ENV_RELEASE);
      try { o.stop(Math.max(hardStop + 0.02, when + ENV_RELEASE + 0.02)); } catch(_) {}
    }
  });

  // Tracking for watchdog
  trackVoice(o, plannedStop, ch, g);
}

function pianoLiteVoice(ch, note, vel, when) {
  const st = channels[ch];

  // Velocity scaling (0..1); keep a safe floor
  const v = Math.max(1, vel) / 127;

  // Micro scheduling guard to avoid "start now" crackles (local only)
  if (when < audioCtx.currentTime + 0.002) {
    when = audioCtx.currentTime + 0.002;
  }

  // Pitch (respect existing globals)
  let f = midiToFreq(note) * Math.pow(2, (st.bend || 0) / 12);
  f *= globalDetuneRatio;

  // Voice bus with headroom and smoother envelope
  const mix = audioCtx.createGain();
  const g = mix.gain;
  const MIN_GAIN = 0.0005;   // safer floor than 0.00012 to avoid denormals
  const HEADROOM = 0.60;     // cap per-voice loudness

  g.setValueAtTime(MIN_GAIN, when);
  g.exponentialRampToValueAtTime(Math.max(MIN_GAIN, HEADROOM * v), when + 0.010);  // fast attack
  g.exponentialRampToValueAtTime(Math.max(MIN_GAIN, HEADROOM * v * 0.62), when + 0.140); // short decay

  // Filter block: lowpass with smooth brightness motion
  const lp = audioCtx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.Q.value = 0.8;
  lp.frequency.setValueAtTime(1500 + 2800 * v, when);
  lp.frequency.setTargetAtTime(1100 + 1200 * v, when + 0.040, 0.120); // smoother than linear ramp

  // DC blocker (local)
  const dc = audioCtx.createBiquadFilter();
  dc.type = 'highpass';
  dc.frequency.value = 14;   // small bump up from 12Hz
  dc.Q.value = 0.707;

  // Oscillators: triangle + detuned sines + octave
  const o1 = audioCtx.createOscillator();
  o1.type = 'triangle';
  o1.frequency.value = f;

  const o2 = audioCtx.createOscillator();
  o2.type = 'sine';
  o2.frequency.value = f;
  o2.detune.value = +3; // cleaner tiny detune in cents

  const o3 = audioCtx.createOscillator();
  o3.type = 'sine';
  o3.frequency.value = f;
  o3.detune.value = -3;

  const o4 = audioCtx.createOscillator();
  o4.type = 'sine';
  o4.frequency.value = f * 2;

  // Partial gains tuned for headroom (sum ~1.01 before bus scaling)
  const g1 = audioCtx.createGain(); g1.gain.value = 0.55;
  const g2 = audioCtx.createGain(); g2.gain.value = 0.18;
  const g3 = audioCtx.createGain(); g3.gain.value = 0.18;
  const g4 = audioCtx.createGain(); g4.gain.value = 0.10;

  // Connect partials to shared filter/DC/mix chain
  o1.connect(g1).connect(lp);
  o2.connect(g2).connect(lp);
  o3.connect(g3).connect(lp);
  o4.connect(g4).connect(lp);
  lp.connect(dc).connect(mix);

  // Hammer/transient noise (local buffer per note as in your design)
  const ns = audioCtx.createBufferSource();
  const sr = audioCtx.sampleRate;
  ns.buffer = getNoiseBuffer('hammer_10ms', sr, 10, 0.10);

  const nh = audioCtx.createBiquadFilter();
  nh.type = 'highpass';
  nh.frequency.value = 2500 + 2000 * v;

  const ng = audioCtx.createGain();
  ng.gain.setValueAtTime(MIN_GAIN, when);
  ng.gain.linearRampToValueAtTime(0.15 * v, when + 0.004);
  ng.gain.exponentialRampToValueAtTime(MIN_GAIN, when + 0.028);

  ns.connect(nh).connect(ng).connect(lp); // shares LP/DC path

  // Destination: respect your globals
  const dest = st.pan ? st.pan : (st.gain || masterIn);
  mix.connect(dest);

  // Start nodes
  o1.start(when); o2.start(when); o3.start(when); o4.start(when); ns.start(when);

  // Stop function with smooth release and local cleanup
  const stopFn = (tStop) => {
    try {
      const releaseTime = 0.320; // slightly shorter than original
      g.cancelScheduledValues(tStop);
      g.setValueAtTime(Math.max(g.value, MIN_GAIN), tStop);
      g.exponentialRampToValueAtTime(MIN_GAIN, tStop + releaseTime);

      const hardStop = Math.max(tStop + releaseTime + 0.020, when + 0.420);
      o1.stop(hardStop); o2.stop(hardStop); o3.stop(hardStop); o4.stop(hardStop);
      ns.stop(Math.max(tStop + 0.050, when + 0.050));
    } catch (e) {}
  };

  stopRegistry[ch].set(note, { stop: stopFn });

  // Best-effort disconnect to keep graph lean (strictly local)
  const cleanup = () => {
    try {
      o1.disconnect(); g1.disconnect();
      o2.disconnect(); g2.disconnect();
      o3.disconnect(); g3.disconnect();
      o4.disconnect(); g4.disconnect();
      ns.disconnect(); nh.disconnect(); ng.disconnect();
      lp.disconnect(); dc.disconnect(); mix.disconnect();
    } catch (e) {}
  };

  // Cleanup after oscillators end (noise is short-lived)
  let endedCount = 0;
  const onEndedOnce = () => { if (++endedCount >= 4) cleanup(); };
  o1.onended = onEndedOnce;
  o2.onended = onEndedOnce;
  o3.onended = onEndedOnce;
  o4.onended = onEndedOnce;

  // Your tracking hooks (unchanged)
  trackVoice(o1, when + 1.2, ch, g);
  trackVoice(o2, when + 1.2, ch, g);
  trackVoice(o3, when + 1.2, ch, g);
  trackVoice(o4, when + 1.2, ch, g);
  trackVoice(ns, when + 0.10, ch, ng.gain);
}
function deepBassVoice(ch, note, vel, when) {
  const st = channels[ch];
  const vlin = Math.max(1, vel) / 127;

  // Micro scheduling guard to avoid "start-now" crackles (esp. mobile)
  if (when < audioCtx.currentTime + 0.002) {
    when = audioCtx.currentTime + 0.002;
  }

  // Base frequency with pitch bend + global detune
  let f = midiToFreq(note) * Math.pow(2, (st.bend || 0) / 12);
  f *= globalDetuneRatio;

  // === Voice bus gain ===
  const mix = audioCtx.createGain();
  const g = mix.gain;
  const MIN = 0.00012;          // safe floor

  // Tiny pre-attack reduces "thump hash" on sub hits
  // Attack to ~0.92*vlin, decay to ~0.72*vlin
  g.setValueAtTime(MIN, when);
  g.linearRampToValueAtTime(0.92 * vlin, when + 0.004);    // shorter pre-attack
  g.linearRampToValueAtTime(0.72 * vlin, when + 0.120);

  // === Tone shaping ===
  // Low-pass first (limit highs)
  const lpPre = audioCtx.createBiquadFilter();
  lpPre.type = 'lowpass';
  lpPre.frequency.setValueAtTime(350 + 700 * vlin, when);
  lpPre.Q.value = 0.7;

  // DC blocker BEFORE waveshaper (prevents bias from being clipped)
  const dcPre = audioCtx.createBiquadFilter();
  dcPre.type = 'highpass';
  dcPre.frequency.setValueAtTime(30, when); // slightly higher than 28
  dcPre.Q.value = 0.707;

  // Soft saturation (lower drive, optional velocity gate)
  const drive = audioCtx.createWaveShaper();
  const driveAmt = (vlin < 0.12) ? 0.0 : 0.64;   // disable color at very low vel
  drive.curve = makeSoftClipCurve(driveAmt);
  drive.oversample = '4x';

  // Post-clip LPF to tame HF added by saturation
  const lpPost = audioCtx.createBiquadFilter();
  lpPost.type = 'lowpass';
  lpPost.frequency.setValueAtTime(1200, when);   // conservative top end for bass
  lpPost.Q.value = 0.6;

  // === Oscillators ===
  const oBody = audioCtx.createOscillator();
  oBody.type = 'triangle';
  oBody.frequency.setValueAtTime(f, when);

  const oSub = audioCtx.createOscillator();
  oSub.type = 'sine';
  oSub.frequency.setValueAtTime(f / 2, when);

  const gBody = audioCtx.createGain(); gBody.gain.value = 0.62;
  const gSub  = audioCtx.createGain(); gSub.gain.value  = 0.88;

  // === Patch wiring ===
  // Partials -> LP (pre) -> DC (pre) -> drive -> LP (post) -> mix
  oBody.connect(gBody).connect(lpPre);
  oSub .connect(gSub ).connect(lpPre);

  lpPre.connect(dcPre).connect(drive).connect(lpPost).connect(mix);

  // Destination (respect pan chain if present)
  const dest = st.pan ? st.pan : (st.gain || masterIn);
  mix.connect(dest);

  // Start
  oBody.start(when);
  oSub.start(when);

  // Stop (smooth exponential into floor, no readback of g.value)
  const stopFn = (tStop) => {
    try {
      const rel = 0.180;
      g.cancelScheduledValues(tStop);
      g.setValueAtTime(Math.max(MIN, 0.001), tStop);  // fixed small start for release
      g.exponentialRampToValueAtTime(MIN, tStop + rel);

      const minStop = Math.max(tStop + rel + 0.020, when + 0.200);
      oBody.stop(minStop);
      oSub.stop(minStop);
    } catch (e) {}
  };

  stopRegistry[ch].set(note, { stop: stopFn });

  // Tracking (unchanged)
  trackVoice(oBody, when + 0.90, ch, g);
  trackVoice(oSub,  when + 0.90, ch, g);
}

function fretlessBassVoice(ch, note, vel, when) {
  const st = channels[ch];
  const v = Math.max(1, vel) / 127;

  // Target frequency (bend + detune)
  const fTarget = midiToFreq(note) * Math.pow(2, (st.bend || 0) / 12) * globalDetuneRatio;

  // Glide (start slightly below pitch, ramp to target)
  const glideCents = st.glideCents ?? 30;             // 0..50 is typical
  const portamentoMs = st.portamentoMs ?? 90;         // 60..120ms feels fretless
  const glideRatio = Math.pow(2, -glideCents / 1200);
  const fStart = Math.max(1e-3, fTarget * glideRatio); // exponential ramp must be >0

  // Main envelope
  const mix = audioCtx.createGain();
  const g = mix.gain;
  g.setValueAtTime(0.00012, when);
  g.linearRampToValueAtTime(v * 0.90, when + 0.010);   // gentle attack
  g.linearRampToValueAtTime(v * 0.70, when + 0.160);   // decay to sustain-ish

  // LP filter + "mwah" peaking resonance
  const lp = audioCtx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.setValueAtTime(360 + 700 * v, when);
  lp.Q.value = 0.8;

  const mwah = audioCtx.createBiquadFilter();
  mwah.type = 'peaking';
  mwah.frequency.setValueAtTime(980, when);            // sweet spot; adjust 900..1100
  mwah.Q.value = 1.3;
  mwah.gain.setValueAtTime(4 + 8 * v, when);           // velocity-lift resonance

  // Body + Sub oscillators
  const oBody = audioCtx.createOscillator();
  oBody.type = 'triangle';
  oBody.frequency.setValueAtTime(fStart, when);
  oBody.frequency.exponentialRampToValueAtTime(fTarget, when + portamentoMs / 1000);

  const oSub = audioCtx.createOscillator();
  oSub.type = 'sine';
  oSub.frequency.setValueAtTime(fStart / 2, when);
  oSub.frequency.exponentialRampToValueAtTime(fTarget / 2, when + portamentoMs / 1000);

  const gBody = audioCtx.createGain();
  gBody.gain.value = 0.60;

  const gSub = audioCtx.createGain();
  gSub.gain.value = 0.90;

  // Soft clip (subtle)
  const drive = audioCtx.createWaveShaper();
  drive.curve = makeSoftClipCurve(0.62); // more linear; fretless likes cleanliness
  drive.oversample = '4x';

  // DC blocker (slightly higher than before)
  const dc = audioCtx.createBiquadFilter();
  dc.type = 'highpass';
  dc.frequency.setValueAtTime(30, when);
  dc.Q.value = 0.707;

  // Delayed vibrato (applied to DETUNE in cents)
  const vibHz = st.vibHz ?? 5.5;
  const vibDepthCents = (st.vibDepthCents ?? 8) * v;   // 0..12 cents typical
  const vibDelayMs = st.vibDelayMs ?? 160;

  const lfoVib = audioCtx.createOscillator();
  lfoVib.type = 'sine';
  lfoVib.frequency.setValueAtTime(vibHz, when);

  const vibGain = audioCtx.createGain();
  vibGain.gain.setValueAtTime(0, when);
  vibGain.gain.linearRampToValueAtTime(vibDepthCents, when + vibDelayMs / 1000);

  // Route LFO to detune (cents)
  lfoVib.connect(vibGain);
  vibGain.connect(oBody.detune);
  vibGain.connect(oSub.detune);

  // Subtle chorus: short modulated delay on the full signal
  const chorusDelay = audioCtx.createDelay(0.030);     // max 30ms
  chorusDelay.delayTime.setValueAtTime(0.012, when);   // base ~12ms

  const lfoCh = audioCtx.createOscillator();
  lfoCh.type = 'sine';
  lfoCh.frequency.setValueAtTime(0.35, when);          // very slow
  const chDepth = audioCtx.createGain();
  chDepth.gain.setValueAtTime(0.0012, when);           // ¬±1.2ms (seconds)

  lfoCh.connect(chDepth).connect(chorusDelay.delayTime);

  const chorusMix = audioCtx.createGain();
  chorusMix.gain.setValueAtTime(0.22, when);           // wet mix

  const dryGain = audioCtx.createGain();
  dryGain.gain.setValueAtTime(0.85, when);             // dry backbone

  // Wiring (serial body->lp->mwah->drive->dc; split into dry+chorus)
  oBody.connect(gBody).connect(lp);
  oSub .connect(gSub).connect(lp);
  lp.connect(mwah).connect(drive).connect(dc);

  dc.connect(dryGain).connect(mix);
  dc.connect(chorusDelay).connect(chorusMix).connect(mix);

  // Destination
  const dest = st.pan ? st.pan : (st.gain || masterIn);
  mix.connect(dest);

  // Starts
  oBody.start(when);
  oSub.start(when);
  lfoVib.start(when);
  lfoCh.start(when);

  // Stops
  const stopFn = (tStop) => {
    try {
      // Fade main
      g.cancelScheduledValues(tStop);
      g.setValueAtTime(g.value, tStop);
      g.linearRampToValueAtTime(0.00012, tStop + 0.200);

      // Ramp down vibrato & chorus modulation to avoid end-of-note wobble
      vibGain.gain.linearRampToValueAtTime(0, tStop + 0.080);
      chDepth.gain.linearRampToValueAtTime(0, tStop + 0.080);

      const minStop = Math.max(tStop + 0.220, when + 0.220);
      oBody.stop(minStop);
      oSub.stop(minStop);
      lfoVib.stop(minStop);
      lfoCh.stop(minStop);
    } catch (e) {}
  };

  stopRegistry[ch].set(note, { stop: stopFn });

  // Housekeeping
  trackVoice(oBody, when + 1.20, ch, g);
  trackVoice(oSub,  when + 1.20, ch, g);
}
function guitarLiteVoice(ch, note, vel, when) {
  const st = channels[ch];
  const v = Math.max(1, vel) / 127;

  // Micro scheduling guard to avoid "start-now" crackles (local only)
  if (when < audioCtx.currentTime + 0.003) {
    when = audioCtx.currentTime + 0.003;
  }

  // Pitch with bend and global detune
  let f = midiToFreq(note) * Math.pow(2, (st.bend || 0) / 12);
  f *= globalDetuneRatio;

  // Voice bus gain with headroom + smoother envelope
  const mix = audioCtx.createGain();
  const g = mix.gain;
  const MIN_GAIN = 0.0005;   // safer floor to avoid denormals/zipper
  const HEADROOM = 0.65;     // per-voice loudness cap

  g.setValueAtTime(MIN_GAIN, when);
  g.exponentialRampToValueAtTime(Math.max(MIN_GAIN, HEADROOM * v * 0.95), when + 0.008); // twangy fast attack
  g.exponentialRampToValueAtTime(Math.max(MIN_GAIN, HEADROOM * v * 0.42), when + 0.140); // brief decay

  // Filters: focus steel-guitar bite, keep highs but tame fizz
  const bp = audioCtx.createBiquadFilter(); // emphasize ~2‚Äì4 kHz
  bp.type = 'bandpass';
  bp.frequency.setValueAtTime(2200, when);
  bp.Q.value = 1.2;

  const lp = audioCtx.createBiquadFilter(); // gentle lowpass top-end
  lp.type = 'lowpass';
  lp.frequency.setValueAtTime(4400, when);
  lp.Q.value = 0.6;

  const dc = audioCtx.createBiquadFilter(); // DC blocker
  dc.type = 'highpass';
  dc.frequency.value = 14;
  dc.Q.value = 0.707;

  // --- Partials: triangle fundamental + slightly detuned saw (bright)
  const o1 = audioCtx.createOscillator();
  o1.type = 'triangle';
  o1.frequency.value = f;

  const o2 = audioCtx.createOscillator();
  o2.type = 'sawtooth';
  o2.frequency.value = f;

  // Small static detune to widen; steel often has subtle doubling
  o1.detune.setValueAtTime(+2, when);
  o2.detune.setValueAtTime(-2, when);

  // Gentle pitch settle (like string stiffness) in first ~80 ms
  try {
    o1.frequency.linearRampToValueAtTime(o1.frequency.value * 0.998, when + 0.080);
  } catch (e) {}
  try {
    o2.frequency.linearRampToValueAtTime(o2.frequency.value * 0.998, when + 0.080);
  } catch (e) {}

  // --- Vibrato LFO (classic steel) with delayed onset
  const lfo = audioCtx.createOscillator();
  lfo.type = 'sine';
  lfo.frequency.value = 5.6; // steel vibrato ~5‚Äì6 Hz

  const vibDepth = audioCtx.createGain(); // in cents
  vibDepth.gain.setValueAtTime(0, when);
  vibDepth.gain.linearRampToValueAtTime(12 * v, when + 0.080); // fade-in vibrato depth (~¬±12 cents)
  lfo.connect(vibDepth);
  vibDepth.connect(o1.detune);
  vibDepth.connect(o2.detune);

  // --- Pick/attack noise (short, bright)
  const ns = audioCtx.createBufferSource();
  const sr = audioCtx.sampleRate;
  const nlen = Math.floor(sr * 0.010);
  const nbuf = audioCtx.createBuffer(1, nlen, sr);
  const nd = nbuf.getChannelData(0);
  for (let i = 0; i < nlen; i++) nd[i] = (Math.random() * 2 - 1);
  ns.buffer = nbuf;

  const nHP = audioCtx.createBiquadFilter();
  nHP.type = 'highpass';
  nHP.frequency.value = 3500 + 1500 * v; // velocity-brightened pick

  const nG = audioCtx.createGain();
  nG.gain.setValueAtTime(MIN_GAIN, when);
  nG.gain.linearRampToValueAtTime(0.16 * v, when + 0.003);
  nG.gain.exponentialRampToValueAtTime(MIN_GAIN, when + 0.030);

  // --- Comb resonance for "steel" metallic twang (short delay + feedback)
  const combDelay = audioCtx.createDelay();
  combDelay.delayTime.setValueAtTime(0.0036 + 0.0003 * v, when); // ~3.6‚Äì3.9 ms

  const combFB = audioCtx.createGain();      // feedback
  combFB.gain.value = 0.20;

  const combFF = audioCtx.createGain();      // feedforward mix into LP
  combFF.gain.value = 0.55;

  // Build comb loop
  combDelay.connect(combFB).connect(combDelay);

  // --- Routing
  // Partials -> BP (core tone)
  o1.connect(bp);
  o2.connect(bp);

  // Direct path: BP -> LP -> DC -> mix
  bp.connect(lp);
  lp.connect(dc).connect(mix);

  // Comb path: BP -> combDelay -> combFF -> LP (summing for metallic sheen)
  bp.connect(combDelay);
  combDelay.connect(combFF).connect(lp);

  // Noise (pick) -> BP (so it shares tone shaping) 
  ns.connect(nHP).connect(nG).connect(bp);

  // Destination
  const dest = st.pan ? st.pan : (st.gain || masterIn);
  mix.connect(dest);

  // Start
  lfo.start(when);
  o1.start(when);
  o2.start(when);
  ns.start(when);

  // Stop & cleanup
  const stopFn = (tStop) => {
    try {
      const releaseTime = 0.380; // a touch longer sustain than jazz
      g.cancelScheduledValues(tStop);
      g.setValueAtTime(Math.max(g.value, MIN_GAIN), tStop);
      g.exponentialRampToValueAtTime(MIN_GAIN, tStop + releaseTime);

      const hardStop = Math.max(tStop + releaseTime + 0.020, when + 0.360);
      o1.stop(hardStop);
      o2.stop(hardStop);
      lfo.stop(hardStop);
      ns.stop(Math.max(tStop + 0.050, when + 0.050));
    } catch (e) {}
  };

  stopRegistry[ch].set(note, { stop: stopFn });

  // Best-effort disconnect to keep graph lean
  const cleanup = () => {
    try {
      o1.disconnect(); o2.disconnect();
      lfo.disconnect(); vibDepth.disconnect();
      ns.disconnect(); nHP.disconnect(); nG.disconnect();
      bp.disconnect(); lp.disconnect(); dc.disconnect();
      combDelay.disconnect(); combFB.disconnect(); combFF.disconnect();
      mix.disconnect();
    } catch (e) {}
  };

  // Cleanup when both oscillators end (noise is short-lived)
  let endedCount = 0;
  const onEndedOnce = () => { if (++endedCount >= 2) cleanup(); };
  o1.onended = onEndedOnce;
  o2.onended = onEndedOnce;

  // Tracking hooks (unchanged)
  trackVoice(o1, when + 0.90, ch, g);
  trackVoice(o2, when + 0.90, ch, g);
  trackVoice(ns, when + 0.06, ch, nG.gain);
}
// === Hi-hat choke registry (global) ===
// Tracks the currently playing Open Hat so Closed Hat can choke it.
const hiHatRegistry = { open: null };
// === DrumLite feature flags (optional) ===
const DrumLiteFlags = {
  snareRollHighVel: true,   // enable roll when velocity >= 110
  snareRollVelThresh: 110   // threshold
};
// Tracks the currently ringing Triangle (open) so Mute can choke it.
const triangleRegistry = { open: null };

function drumLiteVoice(ch, note, vel, when, st) {
    
  // Gentle velocity curve (livelier feel without extremes)
  const vlin = Math.max(1, vel) / 127;
  const v = Math.pow(vlin, 0.85);

  const minDur = MIN_NOTE_MS_DRUMS / 1000;
  // Ensure per-channel stop registry exists
if (!stopRegistry[ch]) {
  stopRegistry[ch] = new Map();
}
¬†

  // === KICK: notes 35/36 (sine body + transient click) ===
  if (note === 35 || note === 36) {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.00012, when);
    g.gain.linearRampToValueAtTime(0.95 * v, when + 0.006);
    g.gain.exponentialRampToValueAtTime(0.00012, when + 0.18);

    osc.frequency.setValueAtTime(95, when);
    osc.frequency.exponentialRampToValueAtTime(50, when + 0.08);

    const dest = st.gain || masterIn;
    osc.connect(g).connect(dest);
    osc.start(when);

    // --- Kick transient click (adds attack presence) ---
    try {
      const click = audioCtx.createBufferSource();
      const sr = audioCtx.sampleRate;
      const clen = Math.floor(sr * 0.004); // 4 ms burst
      const cbuf = audioCtx.createBuffer(1, clen, sr);
      const cd = cbuf.getChannelData(0);
      for (let i = 0; i < clen; i++) {
        cd[i] = (Math.random() * 2 - 1) * (1 - (i / clen)); // decaying noise
      }
      const chp = audioCtx.createBiquadFilter();
      chp.type = 'highpass';
      chp.frequency.value = 2000; // 1.8‚Äì2.2k Hz range
      const cg = audioCtx.createGain();
      cg.gain.setValueAtTime(0.12 * vlin, when);

      click.buffer = cbuf;
      click.connect(chp).connect(cg).connect(dest);
      click.start(when);
      click.stop(when + 0.006);
    } catch (_) {}

    const stopAt = when + 0.20;
    stopRegistry[ch].set(note, {
      stop: (t) => {
        try { osc.stop(Math.max(stopAt, t)); } catch (e) {}
      }
    });
    trackVoice(osc, stopAt, ch, g.gain);
    return;
  }
// === Snare Roll: note 38 with high velocity (multi-tap buzz) ===
// Place this BEFORE your existing "SNARE: notes 38/40" block.
// === Snare Roll: note 38 @ high velocity (multi-tap buzz) ===
// === Rimshot / Side Stick: note 37 (bright snap) ===
if (note === 37) {
  const sr = audioCtx.sampleRate;
  const dur = 0.065;
  const len = Math.floor(sr * dur);
  const buf = audioCtx.createBuffer(1, len, sr);
  const d   = buf.getChannelData(0);
  for (let i = 0; i < len; i++) {
    const r = Math.random() * 2 - 1;
    d[i] = (i > 0 ? d[i - 1] * 0.10 + r * 0.90 : r);
  }
  const noise = audioCtx.createBufferSource(); noise.buffer = buf;

  const bp = audioCtx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 2400; bp.Q.value = 0.8;
  const hp = audioCtx.createBiquadFilter(); hp.type = 'highpass';  hp.frequency.value = 3500; hp.Q.value = 0.7;

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.00012, when);
  g.gain.linearRampToValueAtTime(0.55 * v, when + 0.003);
  g.gain.exponentialRampToValueAtTime(0.00012, when + dur);

  noise.connect(bp).connect(hp).connect(g).connect(st.gain || masterIn);
  noise.start(when);

  const stopAt = when + dur + 0.02;
  stopRegistry[ch].set(note, { stop: (t)=>{ try{ noise.stop(Math.max(stopAt,t)); }catch(_){} } });
  trackVoice(noise, stopAt, ch, g.gain);
  return;
}
if (note === 38 && vel >= 110) {
  const sr   = audioCtx.sampleRate;
  const dest = st.gain || masterIn;

  // Gentle velocity curve consistent with your engine
  const vlin = Math.max(1, vel) / 127;
  const v    = Math.pow(vlin, 0.85);

  // Roll total duration ~320 ms; 12 micro taps with slight jitter
  const totalDur = 0.32;
  const tapsN    = 12;
  const baseGap  = totalDur / tapsN;
  const tapDur   = 0.045;
  const bodyFreq = 220;
  const bodyQ    = 0.9;
  const airHPF   = 3200;

  for (let i = 0; i < tapsN; i++) {
    const jitter = (Math.random() - 0.5) * 0.006;              // ¬±6 ms timing jitter
    const startT = when + i * baseGap + jitter;

    const phase   = i / (tapsN - 1);
    const env     = Math.sin(phase * Math.PI) * 0.85 + 0.15;   // swell toward middle
    const tapGain = env * 0.75 * v;

    const len  = Math.floor(sr * tapDur);
    const buf  = audioCtx.createBuffer(1, len, sr);
    const d    = buf.getChannelData(0);
    for (let j = 0; j < len; j++) {
      const r = Math.random() * 2 - 1;
      d[j] = (j > 0 ? d[j - 1] * 0.14 + r * 0.86 : r);
    }

    const noise = audioCtx.createBufferSource();
    noise.buffer = buf;

    const bp = audioCtx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = bodyFreq;
    bp.Q.value = bodyQ;

    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = airHPF;
    hp.Q.value = 0.7;

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.00012, startT);
    g.gain.linearRampToValueAtTime(tapGain, startT + 0.003);
    g.gain.exponentialRampToValueAtTime(0.00012, startT + tapDur);

    noise.connect(bp).connect(hp).connect(g).connect(dest);
    noise.start(startT);

    const stopAt = startT + tapDur + 0.02;
    stopRegistry[ch].set(38 + i * 0.0001, {
      stop: (t) => { try { noise.stop(Math.max(stopAt, t)); } catch (_) {} }
    });
    trackVoice(noise, stopAt, ch, g.gain);
  }

  // Important: return so the normal snare branch does not run for this hit
  return;
}
  // === SNARE: notes 38/40 (noise + body + rattle) ===
  if (note === 38 || note === 40) {
    const sr = audioCtx.sampleRate;
    const len = Math.floor(sr * 0.26);
    const buf = audioCtx.createBuffer(1, len, sr);
    const d = buf.getChannelData(0);
    for (let i = 0; i < len; i++) {
      const r = Math.random() * 2 - 1;
      d[i] = (i > 0 ? d[i - 1] * 0.20 + r * 0.80 : r);
    }

    const noise = audioCtx.createBufferSource();
    noise.buffer = buf;

    const bp = audioCtx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 220;
    bp.Q.value = 0.8;

    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 3000;

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.9 * v, when);
    g.gain.exponentialRampToValueAtTime(0.00012, when + 0.26);

    const dest = st.gain || masterIn;
    noise.connect(bp).connect(hp).connect(g).connect(dest);
    noise.start(when);

    // --- Snare body (triangle) for mid punch ---
    try {
      const bodyOsc = audioCtx.createOscillator(); bodyOsc.type = 'triangle';
      bodyOsc.frequency.setValueAtTime(180, when);
      const bodyLP = audioCtx.createBiquadFilter(); bodyLP.type = 'lowpass'; bodyLP.frequency.value = 900;
      const bodyG = audioCtx.createGain();
      bodyG.gain.setValueAtTime(0.18 * v, when);
      bodyG.gain.exponentialRampToValueAtTime(0.00012, when + 0.12);
      bodyOsc.connect(bodyLP).connect(bodyG).connect(dest);
      bodyOsc.start(when); bodyOsc.stop(when + 0.14);
    } catch (_) {}

    // --- Extra rattle (HF noise) ---
    try {
      const rHP = audioCtx.createBiquadFilter(); rHP.type = 'highpass'; rHP.frequency.value = 6000;
      const rG = audioCtx.createGain();
      rG.gain.setValueAtTime(0.10 * v, when);
      rG.gain.exponentialRampToValueAtTime(0.00012, when + 0.10);
      // small independent 20ms HF burst
      const rlen = Math.floor(sr * 0.020);
      const rbuf = audioCtx.createBuffer(1, rlen, sr);
      const rd = rbuf.getChannelData(0);
      for (let i = 0; i < rlen; i++) rd[i] = Math.random() * 2 - 1;
      const ratt = audioCtx.createBufferSource();
      ratt.buffer = rbuf;
      ratt.connect(rHP).connect(rG).connect(dest);
      ratt.start(when); ratt.stop(when + 0.020);
    } catch (_) {}

    const stopAt = when + 0.28;
    stopRegistry[ch].set(note, {
      stop: (t) => {
        try { noise.stop(Math.max(stopAt, t)); } catch (e) {}
      }
    });
    trackVoice(noise, stopAt, ch, g.gain);
    return;
  }

  // === HI-HATS: 42 closed / 46 open ‚Äî with choke logic ===
  if (note === 42 || note === 46) {
    // Choke any ringing open hat when closed hat is triggered
   if (note === 42 && hiHatRegistry.open) {
  chokeSmooth(hiHatRegistry.open, when, 18 /*ms*/);
  hiHatRegistry.open = null;
}

    const dur = (note === 46 ? Math.max(minDur, 0.32) : Math.max(minDur, 0.16));
    const sr = audioCtx.sampleRate;
    const len = Math.floor(sr * dur);
    const buf = audioCtx.createBuffer(1, len, sr);
    const d = buf.getChannelData(0);
    for (let i = 0; i < len; i++) {
      const r = Math.random() * 2 - 1;
      d[i] = (i > 0 ? d[i - 1] * 0.12 + r * 0.88 : r);
    }

    const noise = audioCtx.createBufferSource();
    noise.buffer = buf;

    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 7000;

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.7 * v, when);
    g.gain.exponentialRampToValueAtTime(0.00012, when + dur);

    const dest = st.gain || masterIn;
    noise.connect(hp).connect(g).connect(dest);
    noise.start(when);

    // Remember open hat source so closed hat can choke it later
    if (note === 46) {
      hiHatRegistry.open = noise;
    }

    const stopAt = when + dur + 0.02;
    stopRegistry[ch].set(note, {
      stop: (t) => {
        try { noise.stop(Math.max(stopAt, t)); } catch (e) {}
      }
    });
    trackVoice(noise, stopAt, ch, g.gain);
    return;
  }

  // === CRASH/RIDE: notes 49/51 ===
  if (note === 49 || note === 51) {
    const dur = (note === 49 ? 1.5 : 1.1);
    const sr = audioCtx.sampleRate;
    const len = Math.floor(sr * dur);
    const buf = audioCtx.createBuffer(1, len, sr);
    const d = buf.getChannelData(0);
    for (let i = 0; i < len; i++) {
      const r = Math.random() * 2 - 1;
      d[i] = (i > 0 ? d[i - 1] * 0.10 + r * 0.90 : r);
    }

    const noise = audioCtx.createBufferSource();
    noise.buffer = buf;

    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 5000;

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.65 * v, when);
    g.gain.exponentialRampToValueAtTime(0.00012, when + dur);

    const dest = st.gain || masterIn;
    noise.connect(hp).connect(g).connect(dest);
    noise.start(when);

    const stopAt = when + dur + 0.02;
    stopRegistry[ch].set(note, {
      stop: (t) => {
        try { noise.stop(Math.max(stopAt, t)); } catch (e) {}
      }
    });
    trackVoice(noise, stopAt, ch, g.gain);
    return;
  }

  // === OPTIONAL: TOMS (45/47/50) ===
  if (note === 45 || note === 47 || note === 50) {
    const sr = audioCtx.sampleRate;
    const freq = (note === 45) ? 120 : (note === 47) ? 160 : 220;
    const dur = 0.18;

    const osc = audioCtx.createOscillator(); osc.type = 'sine';
    const bp  = audioCtx.createBiquadFilter(); bp.type = 'bandpass'; bp.Q.value = 1.0; bp.frequency.value = freq;
    const g   = audioCtx.createGain();
    g.gain.setValueAtTime(0.65 * v, when);
    g.gain.exponentialRampToValueAtTime(0.00012, when + dur);

    const dest = st.gain || masterIn;
    osc.connect(bp).connect(g).connect(dest);
    osc.start(when); osc.stop(when + dur + 0.02);

    stopRegistry[ch].set(note, {
      stop: (t) => {
        try { osc.stop(Math.max(when + dur, t)); } catch (_) {}
      }
    });
    trackVoice(osc, when + dur, ch, g.gain);
    return;
  }
  // === Pedal Hi-hat: note 44 (short "chick" + choke any open hat) ===
if (note === 44) {
  // Choke (stop) any currently ringing open hi-hat
  if (hiHatRegistry.open) {
    try {
      hiHatRegistry.open.stop(when);
      hiHatRegistry.open.disconnect();
    } catch (_) {}
    hiHatRegistry.open = null;
  }

  // Very short hi-hat "chick": ~80ms, high-pass filtered noise
  const dur = Math.max(MIN_NOTE_MS_DRUMS/1000, 0.08); // ~80ms
  const sr  = audioCtx.sampleRate;
  const len = Math.floor(sr * dur);
  const buf = audioCtx.createBuffer(1, len, sr);
  const d   = buf.getChannelData(0);

  // Smooth-ish white noise (slight correlation softens hashy edge)
  for (let i = 0; i < len; i++) {
    const r = Math.random() * 2 - 1;
    d[i] = (i > 0 ? d[i - 1] * 0.10 + r * 0.90 : r);
  }

  const noise = audioCtx.createBufferSource();
  noise.buffer = buf;

  const hp = audioCtx.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 6500;  // slightly softer than closed hat 42
  hp.Q.value = 0.7;

  const g = audioCtx.createGain();
  // Use your velocity curve variable `v` (already computed at top of function)
  g.gain.setValueAtTime(0.60 * v, when);
  g.gain.exponentialRampToValueAtTime(0.00012, when + dur);

  const dest = st.gain || masterIn;
  noise.connect(hp).connect(g).connect(dest);
  noise.start(when);

  const stopAt = when + dur + 0.02;
  stopRegistry[ch].set(note, {
    stop: (t) => {
      try { noise.stop(Math.max(stopAt, t)); } catch (e) {}
    }
  });
  trackVoice(noise, stopAt, ch, g.gain);
  return;
}
// === Hand Clap: note 39 (multi-tap bright noise) ===
if (note === 39) {
  const sr   = audioCtx.sampleRate;
  const dest = st.gain || masterIn;

  // Tap timings (seconds) relative to 'when' with velocity-scaled gains
  const taps = [
    { t: 0.00, gain: 0.70 },  // strongest
    { t: 0.022, gain: 0.46 }, // medium
    { t: 0.044, gain: 0.32 }  // light
  ];
  const tapDur = 0.075; // ~75ms per tap

  for (let i = 0; i < taps.length; i++) {
    const startT = when + taps[i].t;
    const len    = Math.floor(sr * tapDur);

    // White noise with slight correlation (softens hashy edge)
    const buf = audioCtx.createBuffer(1, len, sr);
    const d   = buf.getChannelData(0);
    for (let j = 0; j < len; j++) {
      const r = Math.random() * 2 - 1;
      d[j] = (j > 0 ? d[j - 1] * 0.12 + r * 0.88 : r);
    }

    const noise = audioCtx.createBufferSource();
    noise.buffer = buf;

    // Filters: body (bandpass ~1.8k) + air (highpass ~3.2k)
    const bp = audioCtx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 1800;
    bp.Q.value = 0.65;

    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 3200;
    hp.Q.value = 0.7;

    // Envelope: tiny attack, quick decay
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.00012, startT);
    g.gain.linearRampToValueAtTime(taps[i].gain * v, startT + 0.004);
    g.gain.exponentialRampToValueAtTime(0.00012, startT + tapDur);

    noise.connect(bp).connect(hp).connect(g).connect(dest);
    noise.start(startT);

    // Register stop for panic/cleanup; unique key per tap to avoid overwrite
    const stopAt = startT + tapDur + 0.02;
    stopRegistry[ch].set(note + i * 0.0001, {
      stop: (t) => {
        try { noise.stop(Math.max(stopAt, t)); } catch (_) {}
      }
    });

    trackVoice(noise, stopAt, ch, g.gain);
  }

  return;
}
// === Chinese Cymbal: 52 (trashier, longer) ===
if (note === 52) {
  const dur = 1.6, sr = audioCtx.sampleRate, len = Math.floor(sr * dur);
  const buf = audioCtx.createBuffer(1, len, sr); const d = buf.getChannelData(0);
  for (let i = 0; i < len; i++) { const r = Math.random() * 2 - 1; d[i] = (i > 0 ? d[i - 1] * 0.14 + r * 0.86 : r); }
  const noise = audioCtx.createBufferSource(); noise.buffer = buf;
  const hp = audioCtx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 4200;
  const g = audioCtx.createGain(); g.gain.setValueAtTime(0.62 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + dur);
  noise.connect(hp).connect(g).connect(st.gain || masterIn); noise.start(when);
  const stopAt = when + dur + 0.02; stopRegistry[ch].set(note, { stop:(t)=>{ try{ noise.stop(Math.max(stopAt,t)); }catch(_){} } });
  trackVoice(noise, stopAt, ch, g.gain); return;
}

// === Ride Bell: 53 (metal ping) ===
if (note === 53) {
  const osc1 = audioCtx.createOscillator(); osc1.type = 'sine'; osc1.frequency.value = 1200;
  const osc2 = audioCtx.createOscillator(); osc2.type = 'sine'; osc2.frequency.value = 1800;
  const g = audioCtx.createGain(); g.gain.setValueAtTime(0.45 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + 0.45);
  const dest = st.gain || masterIn; osc1.connect(g).connect(dest); osc2.connect(g); osc1.start(when); osc2.start(when); osc1.stop(when + 0.47); osc2.stop(when + 0.47);
  stopRegistry[ch].set(note, { stop:(t)=>{ try{ osc1.stop(Math.max(when+0.45,t)); osc2.stop(Math.max(when+0.45,t)); }catch(_){} } });
  trackVoice(g, when + 0.45, ch, g.gain); return;
}

// === Splash: 55 (short crash) ===
if (note === 55) {
  const dur = 0.9, sr = audioCtx.sampleRate, len = Math.floor(sr * dur);
  const buf = audioCtx.createBuffer(1, len, sr); const d = buf.getChannelData(0);
  for (let i = 0; i < len; i++) { const r = Math.random() * 2 - 1; d[i] = (i > 0 ? d[i - 1] * 0.10 + r * 0.90 : r); }
  const noise = audioCtx.createBufferSource(); noise.buffer = buf;
  const hp = audioCtx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 5200;
  const g = audioCtx.createGain(); g.gain.setValueAtTime(0.60 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + dur);
  noise.connect(hp).connect(g).connect(st.gain || masterIn); noise.start(when);
  const stopAt = when + dur + 0.02; stopRegistry[ch].set(note, { stop:(t)=>{ try{ noise.stop(Math.max(stopAt,t)); }catch(_){} } });
  trackVoice(noise, stopAt, ch, g.gain); return;
}
// === Cowbell: 56 (metallic) ===
if (note === 56) {
  const osc1 = audioCtx.createOscillator(); osc1.type = 'square'; osc1.frequency.value = 540;
  const osc2 = audioCtx.createOscillator(); osc2.type = 'square'; osc2.frequency.value = 800;
  const bp   = audioCtx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 700; bp.Q.value = 6.0;
  const g    = audioCtx.createGain(); g.gain.setValueAtTime(0.55 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + 0.30);
  const dest = st.gain || masterIn; osc1.connect(bp).connect(g).connect(dest); osc2.connect(bp);
  osc1.start(when); osc2.start(when); osc1.stop(when + 0.32); osc2.stop(when + 0.32);
  stopRegistry[ch].set(note,{stop:(t)=>{try{osc1.stop(Math.max(when+0.30,t));osc2.stop(Math.max(when+0.30,t));}catch(_){}}});
  trackVoice(g, when + 0.30, ch, g.gain); return;
}

// === Crash 2: 57 ===
if (note === 57) {
  const dur = 1.4, sr = audioCtx.sampleRate, len = Math.floor(sr * dur);
  const buf = audioCtx.createBuffer(1, len, sr); const d = buf.getChannelData(0);
  for (let i = 0; i < len; i++) { const r = Math.random() * 2 - 1; d[i] = (i > 0 ? d[i - 1] * 0.12 + r * 0.88 : r); }
  const noise = audioCtx.createBufferSource(); noise.buffer = buf;
  const hp = audioCtx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 5000;
  const g = audioCtx.createGain(); g.gain.setValueAtTime(0.62 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + dur);
  noise.connect(hp).connect(g).connect(st.gain || masterIn); noise.start(when);
  const stopAt = when + dur + 0.02; stopRegistry[ch].set(note, { stop:(t)=>{ try{ noise.stop(Math.max(stopAt,t)); }catch(_){} } });
  trackVoice(noise, stopAt, ch, g.gain); return;
}
// === Vibra-slap: 58 (rattle tail) ===
if (note === 58) {
  const dur = 1.0, sr = audioCtx.sampleRate, len = Math.floor(sr * dur);
  const buf = audioCtx.createBuffer(1, len, sr); const d = buf.getChannelData(0);
  for (let i = 0; i < len; i++) { const r = Math.random()*2-1; d[i] = (i>0 ? d[i-1]*0.18 + r*0.82 : r); }
  const noise = audioCtx.createBufferSource(); noise.buffer = buf;
  const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 1200;
  const g  = audioCtx.createGain(); g.gain.setValueAtTime(0.42 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + dur);
  noise.connect(lp).connect(g).connect(st.gain || masterIn); noise.start(when);
  const stopAt = when + dur + 0.02; stopRegistry[ch].set(note,{stop:(t)=>{try{noise.stop(Math.max(stopAt,t));}catch(_){}}});
  trackVoice(noise, stopAt, ch, g.gain); return;
}

// === Ride Cymbal 2: 59 (slightly darker) ===
if (note === 59) {
  const dur = 1.0, sr = audioCtx.sampleRate, len = Math.floor(sr * dur);
  const buf = audioCtx.createBuffer(1, len, sr); const d = buf.getChannelData(0);
  for (let i = 0; i < len; i++) { const r = Math.random() * 2 - 1; d[i] = (i > 0 ? d[i - 1] * 0.12 + r * 0.88 : r); }
  const noise = audioCtx.createBufferSource(); noise.buffer = buf;
  const hp = audioCtx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 4600;
  const g = audioCtx.createGain(); g.gain.setValueAtTime(0.60 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + dur);
  noise.connect(hp).connect(g).connect(st.gain || masterIn); noise.start(when);
  const stopAt = when + dur + 0.02; stopRegistry[ch].set(note, { stop:(t)=>{ try{ noise.stop(Math.max(stopAt,t)); }catch(_){} } });
  trackVoice(noise, stopAt, ch, g.gain); return;
}
// === Bongos: 60 hi / 61 low ===
if (note === 60 || note === 61) {
  const freq = (note === 60) ? 540 : 400;
  const dur  = 0.12;
  const osc = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value=freq;
  const bp  = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=freq; bp.Q.value=3.0;
  const g   = audioCtx.createGain(); g.gain.setValueAtTime(0.50 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + dur);
  const dest = st.gain || masterIn; osc.connect(bp).connect(g).connect(dest); osc.start(when); osc.stop(when+dur+0.02);
  stopRegistry[ch].set(note,{stop:(t)=>{try{osc.stop(Math.max(when+dur,t));}catch(_){}}}); trackVoice(osc, when+dur, ch, g.gain); return;
}

// === Congas: 62 mute hi / 63 open hi / 64 low ===
if (note === 62 || note === 63 || note === 64) {
  const freq = (note === 64) ? 220 : 320;
  const dur  = (note === 63) ? 0.22 : 0.14;
  const osc = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value=freq;
  const bp  = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=freq; bp.Q.value=2.2;
  const g   = audioCtx.createGain(); g.gain.setValueAtTime((note===63?0.55:0.48)*v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + dur);
  const dest = st.gain || masterIn; osc.connect(bp).connect(g).connect(dest); osc.start(when); osc.stop(when+dur+0.02);
  stopRegistry[ch].set(note,{stop:(t)=>{try{osc.stop(Math.max(when+dur,t));}catch(_){}}}); trackVoice(osc, when+dur, ch, g.gain); return;
}

// === Timbales: 65 hi / 66 low ===
if (note === 65 || note === 66) {
  const freq = (note === 65) ? 650 : 520;
  const dur  = 0.20;
  const osc = audioCtx.createOscillator(); osc.type='triangle'; osc.frequency.value=freq;
  const bp  = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=freq; bp.Q.value=1.6;
  const g   = audioCtx.createGain(); g.gain.setValueAtTime(0.55 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + dur);
  const dest = st.gain || masterIn; osc.connect(bp).connect(g).connect(dest); osc.start(when); osc.stop(when+dur+0.02);
  stopRegistry[ch].set(note,{stop:(t)=>{try{osc.stop(Math.max(when+dur,t));}catch(_){}}}); trackVoice(osc, when+dur, ch, g.gain); return;
}

// === Agogo: 67 high / 68 low (two sines) ===
if (note === 67 || note === 68) {
  const freq = (note === 67) ? 880 : 660;
  const osc1 = audioCtx.createOscillator(); osc1.type='sine'; osc1.frequency.value=freq;
  const osc2 = audioCtx.createOscillator(); osc2.type='sine'; osc2.frequency.value=freq*1.5;
  const g    = audioCtx.createGain(); g.gain.setValueAtTime(0.40 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + 0.30);
  const dest = st.gain || masterIn; osc1.connect(g).connect(dest); osc2.connect(g);
  osc1.start(when); osc2.start(when); osc1.stop(when + 0.32); osc2.stop(when + 0.32);
  stopRegistry[ch].set(note,{stop:(t)=>{try{osc1.stop(Math.max(when+0.30,t));osc2.stop(Math.max(when+0.30,t));}catch(_){}}});
  trackVoice(g, when + 0.30, ch, g.gain); return;
}
// === Tambourine: 54 (jingles multi-tap) ===
if (note === 54) {
  const sr = audioCtx.sampleRate, dest = st.gain || masterIn;
  const taps = [0.00, 0.018, 0.036];
  const tapDur = 0.080;
  for (let i = 0; i < taps.length; i++) {
    const startT = when + taps[i], len = Math.floor(sr * tapDur);
    const buf = audioCtx.createBuffer(1, len, sr), d = buf.getChannelData(0);
    for (let j = 0; j < len; j++) { const r = Math.random()*2-1; d[j] = (j>0 ? d[j-1]*0.10 + r*0.90 : r); }
    const noise = audioCtx.createBufferSource(); noise.buffer = buf;
    const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000;
    const g = audioCtx.createGain(); g.gain.setValueAtTime(0.50 * v, startT); g.gain.exponentialRampToValueAtTime(0.00012, startT + tapDur);
    noise.connect(hp).connect(g).connect(dest); noise.start(startT);
    const stopAt = startT + tapDur + 0.02; stopRegistry[ch].set(note+i*0.0001,{stop:(t)=>{try{noise.stop(Math.max(stopAt,t));}catch(_){}}});
    trackVoice(noise, stopAt, ch, g.gain);
  }
  return;
}



// === Cabasa: 69 (shaker sweep) ===
if (note === 69) {
  const dur = 0.20, sr = audioCtx.sampleRate, len = Math.floor(sr * dur);
  const buf = audioCtx.createBuffer(1, len, sr); const d = buf.getChannelData(0);
  for (let i=0;i<len;i++){const r=Math.random()*2-1; d[i]=(i>0?d[i-1]*0.10 + r*0.90:r);}
  const noise = audioCtx.createBufferSource(); noise.buffer = buf;
  const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=4500;
  const g  = audioCtx.createGain(); g.gain.setValueAtTime(0.40 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when+dur);
  noise.connect(hp).connect(g).connect(st.gain || masterIn); noise.start(when);
  const stopAt = when + dur + 0.02; stopRegistry[ch].set(note,{stop:(t)=>{try{noise.stop(Math.max(stopAt,t));}catch(_){}}});
  trackVoice(noise, stopAt, ch, g.gain); return;
}

// === Maracas: 70 (short shake) ===
if (note === 70) {
  const dur = 0.12, sr = audioCtx.sampleRate, len = Math.floor(sr * dur);
  const buf = audioCtx.createBuffer(1, len, sr); const d = buf.getChannelData(0);
  for (let i=0;i<len;i++){const r=Math.random()*2-1; d[i]=(i>0?d[i-1]*0.10 + r*0.90:r);}
  const noise = audioCtx.createBufferSource(); noise.buffer = buf;
  const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=3000; bp.Q.value=1.0;
  const g  = audioCtx.createGain(); g.gain.setValueAtTime(0.38 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when+dur);
  noise.connect(bp).connect(g).connect(st.gain || masterIn); noise.start(when);
  const stopAt = when + dur + 0.02; stopRegistry[ch].set(note,{stop:(t)=>{try{noise.stop(Math.max(stopAt,t));}catch(_){}}});
  trackVoice(noise, stopAt, ch, g.gain); return;
}

// === Whistles: 71 short / 72 long (with light vibrato) ===
if (note === 71 || note === 72) {
  const freq = 1300;
  const dur  = (note === 72) ? 0.80 : 0.35;
  const osc  = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value=freq;
  // Vibrato (LFO)
  try {
    const lfo = audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=6.2;
    const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 16; // ¬±16 Hz
    lfo.connect(lfoGain).connect(osc.frequency);
    lfo.start(when); lfo.stop(when + dur);
  } catch(_) {}
  const g   = audioCtx.createGain(); g.gain.setValueAtTime(0.40 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when+dur);
  const dest= st.gain || masterIn; osc.connect(g).connect(dest); osc.start(when); osc.stop(when+dur+0.02);
  stopRegistry[ch].set(note,{stop:(t)=>{try{osc.stop(Math.max(when+dur,t));}catch(_){}}}); trackVoice(osc, when+dur, ch, g.gain); return;
}

// === Guiro: 73 short / 74 long (scrape) ===
if (note === 73 || note === 74) {
  const sr = audioCtx.sampleRate;
  const segs = (note === 74) ? 5 : 3;       // multiple short scrapes
  const segDur = 0.08;                      // per segment
  for (let i = 0; i < segs; i++) {
    const startT = when + i * (segDur - 0.02);
    const len = Math.floor(sr * segDur);
    const buf = audioCtx.createBuffer(1, len, sr); const d = buf.getChannelData(0);
    for (let j=0;j<len;j++){const r=Math.random()*2-1; d[j]=(j>0?d[j-1]*0.20 + r*0.80:r);}
    const noise = audioCtx.createBufferSource(); noise.buffer = buf;
    const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1700; bp.Q.value=0.9;
    const g  = audioCtx.createGain(); g.gain.setValueAtTime(0.35 * v, startT); g.gain.exponentialRampToValueAtTime(0.00012, startT+segDur);
    noise.connect(bp).connect(g).connect(st.gain || masterIn); noise.start(startT);
    const stopAt = startT + segDur + 0.02; stopRegistry[ch].set(note+i*0.0001,{stop:(t)=>{try{noise.stop(Math.max(stopAt,t));}catch(_){}}});
    trackVoice(noise, stopAt, ch, g.gain);
  }
  return;
}

// === Claves: 75 (high tok) ===
if (note === 75) {
  const osc = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value=2000;
  const g   = audioCtx.createGain(); g.gain.setValueAtTime(0.42 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + 0.10);
  const dest= st.gain || masterIn; osc.connect(g).connect(dest); osc.start(when); osc.stop(when+0.12);
  stopRegistry[ch].set(note,{stop:(t)=>{try{osc.stop(Math.max(when+0.10,t));}catch(_){}}}); trackVoice(osc, when+0.10, ch, g.gain); return;
}

// === Wood Blocks: 76 hi / 77 low ===
if (note === 76 || note === 77) {
  const freq = (note === 76) ? 1500 : 1200;
  const osc = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value=freq;
  const g   = audioCtx.createGain(); g.gain.setValueAtTime(0.42 * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + 0.11);
  const dest= st.gain || masterIn; osc.connect(g).connect(dest); osc.start(when); osc.stop(when+0.13);
  stopRegistry[ch].set(note,{stop:(t)=>{try{osc.stop(Math.max(when+0.11,t));}catch(_){}}}); trackVoice(osc, when+0.11, ch, g.gain); return;
}
// === Cuica: 78 mute / 79 open (pitch sweep) ===
if (note === 78 || note === 79) {
  const dur = (note === 79) ? 0.40 : 0.22;
  const startF = (note === 79) ? 420 : 520;
  const endF   = (note === 79) ? 640 : 580;
  const osc = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.setValueAtTime(startF, when);
  osc.frequency.exponentialRampToValueAtTime(endF, when + dur * 0.6);
  const g   = audioCtx.createGain(); g.gain.setValueAtTime((note===79?0.45:0.38)*v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + dur);
  const dest= st.gain || masterIn; osc.connect(g).connect(dest); osc.start(when); osc.stop(when + dur + 0.02);
  stopRegistry[ch].set(note,{stop:(t)=>{try{osc.stop(Math.max(when+dur,t));}catch(_){}}}); trackVoice(osc, when+dur, ch, g.gain); return;
}

// === Triangle: 80 mute / 81 open (ding, with choke) ===
if (note === 80 || note === 81) {
  if (note === 80 && triangleRegistry.open) {
    try { triangleRegistry.open.stop(when); triangleRegistry.open.disconnect(); } catch(_) {}
    triangleRegistry.open = null;
  }
  const freq = 1600;
  const dur  = (note === 81) ? 0.70 : 0.18;
  const osc  = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value=freq;
  const g    = audioCtx.createGain(); g.gain.setValueAtTime((note===81?0.42:0.32) * v, when); g.gain.exponentialRampToValueAtTime(0.00012, when + dur);
  const dest = st.gain || masterIn; osc.connect(g).connect(dest); osc.start(when);
  if (note === 81) triangleRegistry.open = osc;
  osc.stop(when + dur + 0.02);
  stopRegistry[ch].set(note,{stop:(t)=>{try{osc.stop(Math.max(when+dur,t));}catch(_){}}}); trackVoice(osc, when+dur, ch, g.gain); return;
}

  // === FALLBACK: short sine beep ===
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.00012, when);
  g.gain.linearRampToValueAtTime(0.4 * v, when + 0.004);
  g.gain.exponentialRampToValueAtTime(0.00012, when + minDur);

  const dest = st.gain || masterIn;
  osc.frequency.value = 800;

  osc.connect(g).connect(dest);
  osc.start(when);

  const stopAt = when + minDur + 0.02;
  stopRegistry[ch].set(note, {
    stop: (t) => {
      try { osc.stop(Math.max(stopAt, t)); } catch (e) {}
    }
  });
  trackVoice(osc, stopAt, ch, g.gain);
}

// instrument ends here
¬†

function voiceWatchdogLoop() {
if (!audioCtx) {
requestAnimationFrame(voiceWatchdogLoop); return;
} const now = audioCtx.currentTime; for (let i = voices.length-1; i >= 0; i--) {
const v = voices[i]; if (now > (v.stopAt + 0.25)) {
try {
v.gain && v.gain.cancelScheduledValues(now); v.gain && v.gain.setValueAtTime(0.00012, now); v.node.stop?.(now+0.01); v.node.disconnect?.();
}catch(e) {} voices.splice(i, 1);
}
} for (let ch = 0; ch < 16; ch++) {
const act = chAct[ch]; const inst = channels[ch].inst || (ch === 9?'drumLite': 'triangle'); const conf = FAILSAFE_TABLE[inst] || {
lvl: 0.30,
idle: 1.8
}; const stale = (now - (act.last || 0)) > conf.idle; const high = act.level > conf.lvl; if (high && stale) {
try {
channels[ch].gain.gain.setTargetAtTime(0.0, now, 0.03);
}catch(e) {} for (let i = voices.length-1; i >= 0; i--) {
const v = voices[i]; if (v.ch === ch) {
try {
v.node.stop?.(now+0.01); v.node.disconnect?.();
}catch(e) {} voices.splice(i, 1);
}
} log(`Failsafe: CH${ch+1} (${inst}) abnormal ‚Äî muted & culled.`); act.level = 0; act.last = now; if (autoRecovery) {
const back = channels[ch].baseGain*channels[ch].expr*channelTargetFactor(ch); try {
channels[ch].gain.gain.setTargetAtTime(back, now+1.2, 0.08);
}catch(e) {} log(`Auto‚Äërecovery: CH${ch+1} ~1.2s.`);
}
}
} requestAnimationFrame(voiceWatchdogLoop);
}
function chRenderLoop() {
const DECAY = 0.92; for (let ch = 0; ch < 16; ch++) {
const a = chAct[ch]; a.level *= DECAY; if (a.level < 0.01) a.level = 0;
} updateMixerMeters(); requestAnimationFrame(chRenderLoop);
}
function hardResetAudio() {
if (!audioCtx) return; const t = audioCtx.currentTime; for (let ch = 0; ch < 16; ch++) {
for (const [note, reg] of stopRegistry[ch].entries()) {
try {
reg.stop?.(t);
}catch(e) {}
} stopRegistry[ch].clear(); noteStartTimes[ch].clear();
} for (let i = voices.length-1; i >= 0; i--) {
const v = voices[i]; try {
v.node.stop?.(t+0.01); v.node.disconnect?.();
}catch(e) {} voices.splice(i, 1);
} try {
transport.gain.cancelScheduledValues(t); transport.gain.setValueAtTime(0.0, t);
}catch(e) {} for (let ch = 0; ch < 16; ch++) {
const g = channels[ch].gain; if (g) {
try {
g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0.0, t);
}catch(e) {}
}
} for (let ch = 0; ch < 16; ch++) {
chAct[ch].level = 0; chAct[ch].last = t;
} updateMixerMeters(); stopSolfOscs();
}
// Soft clip curve with mild pre-drive for smoother saturation.
// k: drive (0.7‚Äì0.9 good), n: resolution (8192 recommended), pregain: gentle pre-amplification.
function makeSoftClipCurve(k = 0.80, n = 8192, pregain = 1.08) {
  const curve = new Float32Array(n);
  for (let i = 0; i < n; i++) {
    const x = ((i / (n - 1)) * 2 - 1) * pregain; // -1..+1, pre-driven
    curve[i] = Math.tanh(k * x);
  }
  return curve;
}
//instrument function


function readBE32(u8, o) {
  const dv = new DataView(u8.buffer, u8.byteOffset || 0, u8.byteLength);
  return dv.getUint32(o, false); // BE
}

function readVLQ(u8, o) {
let v = 0,
b = 0; while (true) {
const c = u8[o+b++]; v = (v<<7)|(c&0x7F); if ((c&0x80) === 0) break;
} return {
value: v,
bytes: b
};
}
function parseSMF(bytes) {
if (String.fromCharCode(bytes[0], bytes[1], bytes[2], bytes[3]) !== 'MThd') throw new Error('Missing MThd'); const hLen = readBE32(bytes, 4); const format = (bytes[8]<<8)|bytes[9]; const nTracks = (bytes[10]<<8)|bytes[11]; const division = (bytes[12]<<8)|bytes[13]; let pos = 8+hLen; const tracks = []; for (let ti = 0; ti < nTracks; ti++) {
if (String.fromCharCode(bytes[pos], bytes[pos+1], bytes[pos+2], bytes[pos+3]) !== 'MTrk') throw new Error('Track '+ti+': missing MTrk'); const tLen = readBE32(bytes, pos+4); const dStart = pos+8; const dEnd = dStart+tLen; tracks.push({
dStart, dEnd
}); pos = dEnd;
} return {
format,
nTracks,
division,
tracks,
bytes
};
}
function buildTempoMap(smf) {
const tpq = smf.division; const tempos = []; for (const tr of smf.tracks) {
let p = tr.dStart,
tick = 0,
run = null; while (p < tr.dEnd) {
const d = readVLQ(smf.bytes, p); p += d.bytes; tick += d.value; let st = smf.bytes[p++]; if (st < 0x80) {
if (run === null) throw new Error('Running status without previous'); p--; st = run;
} else {
run = st;
} if (st === 0xFF) {
const type = smf.bytes[p++]; const ln = readVLQ(smf.bytes, p); p += ln.bytes; const ds = p,
de = p+ln.value; if (type === 0x51 && ln.value === 3) {
const a = smf.bytes[ds],
b = smf.bytes[ds+1],
c = smf.bytes[ds+2]; const usPerQN = (a<<16)|(b<<8)|c; tempos.push({
tick, usPerQN
});
} p = de;
} else if ((st&0xF0) === 0xF0) {
const ln2 = readVLQ(smf.bytes, p); p += ln2.bytes+ln2.value;
} else {
if ((st&0xF0) !== 0xC0 && (st&0xF0) !== 0xD0) p++; p++;
}
}
} if (tempos.length === 0 || tempos[0].tick > 0) tempos.unshift({
tick: 0, usPerQN: 500000
}); tempos.sort((a, b)=>a.tick-b.tick); const tickToSec = (tick)=> {
let sec = 0,
prev = 0; for (let i = 0; i < tempos.length; i++) {
const cur = tempos[i]; const next = tempos[i+1]?.tick ?? tick; const end = Math.min(next, tick); if (end <= prev) break; const dt = end-prev; sec += (dt * (cur.usPerQN/1e6)) / tpq; prev = end; if (end === tick) break;
} return sec;
}; return {
tpq,
tempos,
tickToSec
};
}
function collectEvents(smf) {
const out = []; for (const tr of smf.tracks) {
let p = tr.dStart,
tick = 0,
run = null; while (p < tr.dEnd) {
const d = readVLQ(smf.bytes, p); p += d.bytes; tick += d.value; let st = smf.bytes[p++]; if (st < 0x80) {
if (run === null) throw new Error('Running status without previous'); p--; st = run;
} else {
run = st;
} if (st === 0xFF) {
const type = smf.bytes[p++]; const ln = readVLQ(smf.bytes, p); p += ln.bytes; const ds = p,
de = p+ln.value; p = de; run = null;
} else if ((st&0xF0) === 0xF0) {
const ln2 = readVLQ(smf.bytes, p); p += ln2.bytes+ln2.value; run = null;
} else {
const ch = st&0x0F; const T = (st&0xF0); let d1 = smf.bytes[p++]; let d2 = null; if (T !== 0xC0 && T !== 0xD0) {
d2 = smf.bytes[p++];
} if (T === 0x90) {
const vel = d2|0; if (vel > 0) out.push({
type: 'noteOn', tick, ch, note: d1|0, vel
}); else out.push({
type: 'noteOff', tick, ch, note: d1|0
});
} else if (T === 0x80) {
out.push({
type: 'noteOff', tick, ch, note: d1|0
});
} else if (T === 0xB0) {
out.push({
type: 'cc', tick, ch, cc: d1|0, value: (d2 || 0)|0
});
} else if (T === 0xC0) {
out.push({
type: 'program', tick, ch, prog: d1|0
});
} else if (T === 0xE0) {
const v = ((d2|0)<<7)|(d1|0); out.push({
type: 'pitchbend', tick, ch, lsb: v&0x7F, msb: (v>>7)&0x7F
});
}
}
}
} out.sort((a, b)=>a.tick-b.tick); return out;
}
function collectMetaLyrics(smf) {
const meta = []; for (const tr of smf.tracks) {
let p = tr.dStart,
tick = 0,
run = null; while (p < tr.dEnd) {
const d = readVLQ(smf.bytes, p); p += d.bytes; tick += d.value; let st = smf.bytes[p++]; if (st < 0x80) {
if (run === null) throw new Error('Running status without previous'); p--; st = run;
} else {
run = st;
} if (st === 0xFF) {
const type = smf.bytes[p++]; const ln = readVLQ(smf.bytes, p); p += ln.bytes; const ds = p,
de = p+ln.value; if (type === 0x05 || type === 0x01 || type === 0x03) {
meta.push({
kind: 'meta', tick, type, data: smf.bytes.slice(ds, de)});
} p = de; run = null;
} else if ((st&0xF0) === 0xF0) {
const ln2 = readVLQ(smf.bytes, p); p += ln2.bytes+ln2.value; run = null;
} else {
const T = (st&0xF0); if (T !== 0xC0 && T !== 0xD0) p++; p++;
}
}
} meta.sort((a, b)=>a.tick-b.tick); return meta;
}


(function() {
// Keep decoders ready (your original code already had these; safe to reuse).
let decLatin1 = null, decUtf8 = null;
try {
  decLatin1 = new TextDecoder('latin1');
} catch(_) {}
try {
  decUtf8 = new TextDecoder('utf-8');
} catch(_) {}

function tryDecode(bytes, enc) {
  if (enc === 'utf8' && decUtf8) {
    try { return decUtf8.decode(bytes); } catch(_) {}
  }
  if (enc === 'latin1' && decLatin1) {
    try { return decLatin1.decode(bytes); } catch(_) {}
  }
  // manual fallback
  let s = '';
  for (let i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);
  return s;
}

function autoDecode(bytes) {
  // Try UTF‚Äë8 first; if replacement char appears, fallback to Latin‚Äë1 or raw
  let s = '';
  if (decUtf8) {
    try { s = decUtf8.decode(bytes); } catch(_) { s = ''; }
  }
  const bad = /\uFFFD/.test(s);
  if (!bad && s) return s;
  if (decLatin1) {
    try { return decLatin1.decode(bytes); } catch(_) {}
  }
  let t = '';
  for (let i = 0; i < bytes.length; i++) t += String.fromCharCode(bytes[i]);
  return t;
}

function isHeaderLine(text) {
  const probe = String(text || '').replace(/\r\n?/g, '\n').trim();
  return (
    /^@/.test(probe) ||
    /^TITLE\s*:/.test(probe) ||
    /^ARTIST\s*:/.test(probe) ||
    /^LANGUAGE\s*:/.test(probe) ||
    /^KMIDI\s+KARAOKE\s+FILE$/i.test(probe)
  );
}

function normalizePayload(raw) {
  return String(raw || '')
    .replace(/\u0000/g, '')       // strip NUL
    .replace(/\r\n/g, '\n')     // normalize CRLF -> LF
    .replace(/\r/g, '\n')        // normalize CR -> LF
    .replace(/\u00A0/g, ' ')      // NBSP -> normal space (safe)
    .replace(/\uFF0F/g, '/')      // fullwidth slash -> normal slash
    .replace(/\uFF3C/g, '\\');  // fullwidth backslash -> normal backslash
}

function pushWord(cur, tSec, w, preserveSpaces) {
  if (!cur.obj) cur.obj = { main_time: tSec, text: '', words: [] };
  if (w === '' && !preserveSpaces) return;
  cur.obj.words.push({ t: tSec, w });
}

function finalizeLine(acc) {
  const cur = acc.obj;
  if (!cur || !cur.words.length) { acc.obj = null; return; }
  let txt = '';
  for (let i = 0; i < cur.words.length; i++) txt += cur.words[i].w;
  cur.text = txt;
  acc.lines.push(cur);
  acc.obj = null;
}

// Backward-compatible entry point (keeps your original API)
window.buildLyricsJSON = function(metaEvs, tickToSec, allowTypes, opts) {
  // Defaults aligned with your current preferences
  const options = Object.assign({
    allowTypes: Array.isArray(allowTypes) ? allowTypes : [0x05],
    enc: (opts && opts.enc) || 'latin1',
    preserveSpaces: (opts && 'preserveSpaces' in opts) ? !!opts.preserveSpaces : true,
    splitOnSlash: (opts && 'splitOnSlash' in opts) ? !!opts.splitOnSlash : true,

    // Polishing options:
    skipHeaders: (opts && 'skipHeaders' in opts) ? !!opts.skipHeaders : true,
    allowAtZero: (opts && 'allowAtZero' in opts) ? !!opts.allowAtZero : false,
    coalesceNear: (opts && 'coalesceNear' in opts) ? +opts.coalesceNear : 0.015,
    dedupeAdjacent: (opts && 'dedupeAdjacent' in opts) ? !!opts.dedupeAdjacent : true,
    dedupeSameTime: (opts && 'dedupeSameTime' in opts) ? !!opts.dedupeSameTime : true,
    compressSpaces: (opts && 'compressSpaces' in opts) ? !!opts.compressSpaces : false,

    // Smart slash mode ('smart' | 'strict' | 'off'); default SMART
    splitSlashMode: (opts && opts.splitSlashMode) || 'smart'
  }, opts || {});

  const allow = new Set(options.allowTypes && options.allowTypes.length ? options.allowTypes : [0x05]);

  // --- local helpers for smart slash (simple & fast) ---
  function isLetterOrDigit(ch) { return /[A-Za-z0-9]/.test(ch || ''); }
  function slashShouldSplit(payload, j, mode) {
    if (mode === 'off') return false;
    if (mode === 'strict') return true;
    const prev = payload[j-1] || '';
    const next = payload[j+1] || '';
    if (isLetterOrDigit(prev) && isLetterOrDigit(next)) return false; // keep 'pre/post', 'https://'
    return true; // otherwise boundary
  }

  // Step 1: pre-merge meta payloads that are very near in time
  const merged = [];
  for (let i = 0; i < (metaEvs || []).length; i++) {
    const e = metaEvs[i];
    if (!e || e.kind !== 'meta' || !allow.has(e.type)) continue;

    const sec = tickToSec(e.tick);
    if (!(sec > 0) && !options.allowAtZero) continue;

    let text = (options.enc === 'auto') ? autoDecode(e.data) : tryDecode(e.data, options.enc);
    text = normalizePayload(text);
    if (!text.length) continue;
    if (options.skipHeaders && isHeaderLine(text)) continue;

    if (options.coalesceNear > 0 && merged.length > 0) {
      const prev = merged[merged.length-1];
      const dt = Math.abs(sec - prev.sec);
      if (dt <= options.coalesceNear && e.type === prev.type) {
        // FIX: do not inject artificial newline during coalescing
        prev.raw += text;                 // join payloads (no '\n')
        prev.sec = Math.min(prev.sec, sec); // keep earliest
        continue;
      }
    }
    merged.push({ sec, type: e.type, raw: text });
  }

  // Step 2: build lines and tokens
  const acc = { lines: [], obj: null };

  for (const m of merged) {
    const sec = m.sec;
    const payload = m.raw;

    for (let j = 0; j < payload.length; j++) {
      const ch = payload[j];

      // Backslash control: finalize segment
      if (ch === '\\') {
        const nx = (j+1 < payload.length) ? payload[j+1] : '';
        if (nx === ' ' && options.preserveSpaces) { pushWord(acc, sec, ' ', options.preserveSpaces); j++; }
        else if (nx === '/' || nx === '\\') { j++; }
        finalizeLine(acc);
        continue;
      }

      // Line breaks
      if (ch === '\n' || ch === '\r') { finalizeLine(acc); continue; }

      // SMART SLASH HANDLING
      if (ch === '/') {
        const split = options.splitOnSlash && slashShouldSplit(payload, j, options.splitSlashMode);
        if (split) { finalizeLine(acc); continue; }
        else {
          // Treat '/' as part of token
          let k = j, buf = ch;
          while (k+1 < payload.length) {
            const nx2 = payload[k+1];
            if (nx2 === '\\') break;
            if (nx2 === '\n' || nx2 === '\r') break;
            if (nx2 === '/' && options.splitOnSlash) {
              const shouldSplitNext = (options.splitSlashMode === 'strict') ? true : slashShouldSplit(payload, k+1, options.splitSlashMode);
              if (shouldSplitNext) break;
            }
            if (nx2 === ' ') break;
            buf += nx2; k++;
          }
          j = k;
          pushWord(acc, sec, buf, options.preserveSpaces);
          continue;
        }
      }

      // Spaces: single space inline; consecutive spaces (>=2) => newline
      if (ch === ' ') {
        let k = j;
        while (k+1 < payload.length && payload[k+1] === ' ') k++;
        const count = (k - j + 1);
        if (count >= 2) { j = k; finalizeLine(acc); continue; }
        else {
          if (options.preserveSpaces) pushWord(acc, sec, ' ', options.preserveSpaces);
          j = k; // consume this space
          continue;
        }
      }

      // Greedy token until delimiter
      let k = j, buf = ch;
      while (k+1 < payload.length) {
        const nx2 = payload[k+1];
        if (nx2 === '\\') break;
        if (nx2 === '\n' || nx2 === '\r') break;
        if (nx2 === '/' && options.splitOnSlash) {
          const shouldSplitNext = (options.splitSlashMode === 'strict') ? true : slashShouldSplit(payload, k+1, options.splitSlashMode);
          if (shouldSplitNext) break;
        }
        if (nx2 === ' ') break;
        buf += nx2; k++;
      }
      j = k;
      pushWord(acc, sec, buf, options.preserveSpaces);
    }
  }

  finalizeLine(acc);

  // Step 3: return
  return { lines: acc.lines };
};

})();

function prepareLyLines(json) {
const arr = []; const lines = Array.isArray(json?.lines)? json.lines: []; for (let i = 0; i < lines.length; i++) {
const ln = lines[i] || {},
words = Array.isArray(ln.words)? ln.words: []; const main = (ln.main_time != null)? ln.main_time: (words[0]? (words[0].t || 0): 0); const end = (i+1 < lines.length && lines[i+1].main_time != null)? lines[i+1].main_time: (words.length? (words[words.length-1].t || main): main); arr.push({
idx: i, main, end, words, text: (ln.text || '')
});
} return arr;
}

function renderLyricsStatic() {
  const full = document.getElementById('lyFull');
  const toks = document.getElementById('lyTokens');
  const prev = document.getElementById('lyPrev');
  const curr = document.getElementById('lyCurr');
  const next = document.getElementById('lyNext');

  // Safe guard: when lyrics.json is missing or lines array is empty
  const lines = (function() {
    try {
      return prepareLyLines(lyrics.json);
    } catch(_) {
      return [];
    }
  })();

  // --- Static full lines (unchanged behavior + optional hint) ---
  if (full) {
    full.innerHTML = '';
    if (lines.length === 0) {
      // OPTIONAL: uncomment if you want a hint in Full view
      // const div = document.createElement('div');
      // div.style.margin = '3px 0';
      // div.style.opacity = '0.75';
      // div.textContent = '(No lyrics detected for this source)';
      // full.appendChild(div);
    } else {
      for (const L of lines) {
        const div = document.createElement('div');
        div.style.margin = '3px 0';
        div.textContent = `[${(L.main || 0).toFixed(2)}] ${L.text || ''}`;
        full.appendChild(div);
      }
    }
  }

  // --- Tokens list (unchanged behavior + header + optional hint) ---
  if (toks) {
    toks.innerHTML = '';

    // Header: show chosen/auto source; single-source policy
    const hdr = document.createElement('div');
    hdr.style.color = '#9fbad1';
    hdr.style.margin = '3px 0';
    hdr.textContent = `Source: ${settings.lyrics.source || 'auto'} (single-source)`;
    toks.appendChild(hdr);

    if (lines.length === 0) {
      // OPTIONAL: tiny hint in Tokens panel when empty
      const div = document.createElement('div');
      div.style.margin = '3px 0';
      div.style.opacity = '0.75';
      div.textContent = '(No tokens)';
      toks.appendChild(div);
    } else {
      for (const L of lines) {
        const head = document.createElement('div');
        head.style.color = '#9fbad1';
        head.textContent = `[${(L.main || 0).toFixed(2)}]`;
        toks.appendChild(head);

        for (const w of L.words) {
          const row = document.createElement('div');

          const tm = document.createElement('span');
          tm.style.marginRight = '8px';
          tm.textContent = `[${(w.t || 0).toFixed(2)}]`;

          const tx = document.createElement('span');
          tx.textContent = (w.w === ' ')? '‚ê†': String(w.w || '');

          row.appendChild(tm);
          row.appendChild(tx);
          toks.appendChild(row);
        }
      }
    }
  }

  // --- Clear live rows (unchanged) ---
  if (prev) prev.textContent = '';
  if (curr) curr.textContent = '';
  if (next) next.textContent = '';
}

(function() {
let linesPrepared = [], curIndex=-1; function drawNow(nowRel) {
const prev = document.getElementById('lyPrev'); const curr = document.getElementById('lyCurr'); const next = document.getElementById('lyNext'); if (!curr || !next) return; let li = curIndex; if (li < 0 || !(linesPrepared[li] && linesPrepared[li].main <= nowRel && nowRel < linesPrepared[li].end)) {
while (li+1 < linesPrepared.length && linesPrepared[li+1].main <= nowRel) li++; while (li > 0 && linesPrepared[li].main > nowRel) li--; curIndex = Math.max(0, li);
} const P = (curIndex > 0? linesPrepared[curIndex-1]: null); const C = (linesPrepared[curIndex] || null); const N = (curIndex+1 < linesPrepared.length? linesPrepared[curIndex+1]: null); if (prev) prev.textContent = P? (P.text || ''): ''; curr.innerHTML = ''; if (C) {
let ti=-1; for (let i = 0; i < C.words.length; i++) {
if ((C.words[i].t || 0) <= nowRel) ti = i; else break;
} for (let i = 0; i < C.words.length; i++) {
const sp = document.createElement('span'); sp.className = 'lyTok'; if (i < ti) sp.classList.add('done'); else if (i === ti) sp.classList.add('active'); sp.textContent = (C.words[i].w === ' ')? ' ': String(C.words[i].w || ''); curr.appendChild(sp);
}
} if (next) next.textContent = N? (N.text || ''): '';
}
function loop() {
const nowRel = (audioCtx? audioCtx.currentTime: 0) - (lyrics.startAt || 0); drawNow(nowRel); lyrics.raf = requestAnimationFrame(loop);
}
window.LyricsLive = {
rebuild() {
linesPrepared = prepareLyLines(lyrics.json); curIndex=-1; drawNow(0);
},
start() {
cancelAnimationFrame(lyrics.raf || 0); lyrics.raf = requestAnimationFrame(loop);
},
stop() {
cancelAnimationFrame(lyrics.raf || 0); lyrics.raf = 0;
}
};
})();

//===APPEND: Non-invasive Lyrics countdown (chip + live updater)===
(function() {
const CHIP_ID = 'lyCountdown';
let cRAF = 0;

function ensureCountdownChip() {
if (document.getElementById(CHIP_ID)) return;
const win = document.getElementById('winLyrics');
if (!win) return;
const body = win.querySelector('.winBody');
if (!body) return;
const chip = document.createElement('span');
chip.id = CHIP_ID;
chip.className = 'chip';
chip.title = 'Seconds until next lyric line starts';
chip.style.marginBottom = '8px';
chip.style.display = 'inline-block';
chip.textContent = '‚è± Next in: --';
const anchor = document.getElementById('lyPrev');
if (anchor && anchor.parentNode) {
anchor.parentNode.insertBefore(chip, anchor);
} else {
body.insertBefore(chip, body.firstChild);
}
}

function updateCountdown(nowRel) {
const chip = document.getElementById(CHIP_ID);
if (!chip) return;
const lines = (function() {
try {
return prepareLyLines(lyrics.json);
}catch(_) {
return [];
}
})();
if (!lines.length) {
chip.textContent = '‚è± Next in: --'; chip.style.color = '#9fbad1'; chip.style.display = ''; return;
}
let li = 0;
while (li+1 < lines.length && lines[li+1].main <= nowRel) li++;
const nextMain = (li+1 < lines.length) ? (lines[li+1].main || NaN): NaN;
const delta = (isFinite(nextMain) ? nextMain - nowRel: NaN);
if (!isFinite(delta) || delta < 0) {
chip.textContent = '‚è± Next in: --';
chip.style.color = '#9fbad1';
return;
}
chip.textContent = '‚è± Next in: ' + delta.toFixed(2) + 's';
chip.style.color = (delta < 0.20) ? '#f31260': (delta < 0.50 ? '#f5a524': '#9fbad1');
}

const origRebuild = window.LyricsLive && window.LyricsLive.rebuild;
const origStart = window.LyricsLive && window.LyricsLive.start;
const origStop = window.LyricsLive && window.LyricsLive.stop;
if (window.LyricsLive) {
window.LyricsLive.rebuild = function() {
try {
ensureCountdownChip(); updateCountdown(0);
}catch(_) {}
if (origRebuild) origRebuild.call(window.LyricsLive);
};
window.LyricsLive.start = function() {
if (origStart) origStart.call(window.LyricsLive);
try {
ensureCountdownChip();
}catch(_) {}
cancelAnimationFrame(cRAF || 0);
const loop = ()=> {
const nowRel = (audioCtx? audioCtx.currentTime: 0) - (lyrics.startAt || 0);
try {
updateCountdown(nowRel);
}catch(_) {}
cRAF = requestAnimationFrame(loop);
};
cRAF = requestAnimationFrame(loop);
};
window.LyricsLive.stop = function() {
cancelAnimationFrame(cRAF || 0); cRAF = 0;
if (origStop) origStop.call(window.LyricsLive);
};
}
})();



(function() {
const EPS = 0.0015; function caseTransformText(s) {
const v = KaroState.case || 'none'; if (v === 'upper') return String(s || '').toUpperCase(); if (v === 'lower') return String(s || '').toLowerCase(); if (v === 'cap') return String(s || '').replace(/\b([A-Za-z])/g, (m)=>m.toUpperCase()); if (v === 'sentence') {
const lower = String(s || '').toLowerCase(); const idx = lower.search(/[a-z]/i); if (idx < 0) return lower; return lower.slice(0, idx)+lower[idx].toUpperCase()+lower.slice(idx+1);
} return s || '';
} function prepareLines(json) {
const out = []; const lines = Array.isArray(json?.lines)? json.lines: []; for (let i = 0; i < lines.length; i++) {
const ln = lines[i] || {},
words = Array.isArray(ln.words)? ln.words: []; const main = (ln.main_time != null)? ln.main_time: (words[0]? (words[0].t || 0): 0); const end = (i+1 < lines.length && lines[i+1].main_time != null)? lines[i+1].main_time: (words.length? (words[words.length-1].t || main): main); out.push({
idx: i, main, end, words, text: (ln.text || '')
});
} return out;
} function computeActiveGroup(toks, now) {
let ai=-1; for (let i = 0; i < toks.length; i++) {
if ((toks[i].t || 0) <= now) ai = i; else break;
} if (ai < 0) return {
ai: -1,
L: -1,
R: -1,
at: 0
}; const at = toks[ai].t || 0; let L = ai,
R = ai; while (L-1 >= 0 && Math.abs((toks[L-1].t || 0)-at) <= EPS) {
L--;
} while (R+1 < toks.length && Math.abs((toks[R+1].t || 0)-at) <= EPS) {
R++;
} return {
ai,
L,
R,
at
};
} function letterSpan(ch, progressPct) {
const wrap = document.createElement('span'); wrap.className = 'karoChar'; const base = document.createElement('span'); base.className = 'karoLetter base'; base.textContent = (ch === ' ')? '\u00A0': ch; const hi = document.createElement('span'); hi.className = 'karoLetter hi'; hi.textContent = (ch === ' ')? '\u00A0': ch; wrap.style.setProperty('--kara-progress', Math.max(0, Math.min(100, progressPct))+'%'); wrap.appendChild(base); wrap.appendChild(hi); return wrap;
} function pushWordLetters(tspan, word, progress) {
const len = word.length || 1; const filled = Math.max(0, Math.min(1, progress))*len; const full = Math.floor(filled); const part = Math.max(0, Math.min(1, filled-full)); for (let j = 0; j < len; j++) {
const ch = word[j] || ' '; let p = 0; if (progress >= 1) p = 100; else if (progress <= 0) p = 0; else p = (j < full)?100: ((j === full)?Math.round(part*100): 0); if (KaroState.lettersOnly && ch === ' ') p = 0; tspan.appendChild(letterSpan(ch, p));
}
} function drawTokensInto(el, words, now) {
el.innerHTML = ''; const grp = computeActiveGroup(words, now); const at = grp.at; const nextTime = (grp.R+1 < words.length && words[grp.R+1].t != null)? words[grp.R+1].t: (words.length? (words[words.length-1].t || at): at); const denom = Math.max(0.001, nextTime-at); const progGlobal = Math.max(0, Math.min(1, (now-at)/denom)); for (let i = 0; i < words.length; i++) {
const tspan = document.createElement('span'); tspan.className = 'karoToken'; const w = words[i].w || ''; if (i < grp.L) {
pushWordLetters(tspan, w, 1);
} else if (i >= grp.L && i <= grp.R) {
pushWordLetters(tspan, w, progGlobal);
} else {
pushWordLetters(tspan, w, 0);
} el.appendChild(tspan);
}
} function textTransformWords(words) {
const s = words.map(w => String(w.w || '')).join(''); const t = caseTransformText(s); let pos = 0; const out = []; for (const w of words) {
const len = String(w.w || '').length; out.push({
t: w.t, w: t.slice(pos, pos+len)
}); pos += len;
} return out;
} function draw(nowRel) {
const curr = document.getElementById('karoCurr'); const next = document.getElementById('karoNext'); if (!curr||!next) return; let li=-1; for (let i = 0; i < KaroState.linesPrepared.length; i++){ const L=KaroState.linesPrepared[i]; if(L.main<=nowRel && nowRel<L.end){ li=i; break; } if(L.main>nowRel) break; } if(li<0){ curr.textContent=''; next.textContent=caseTransformText(KaroState.linesPrepared[0]?.text||''); return; } const C=KaroState.linesPrepared[li], N=KaroState.linesPrepared[li+1]||null; const tokens=(KaroState.case==='none')? (C.words||[]) : textTransformWords(C.words||[]); drawTokensInto(curr,tokens,nowRel); next.textContent=caseTransformText(N?.text||''); } function loop(){ const nowRel=(audioCtx? audioCtx.currentTime:0) - (KaroState.startAt||0); draw(nowRel); KaroState.raf=requestAnimationFrame(loop); } window.Karo={ rebuild(){ KaroState.linesPrepared=prepareLines(lyrics.json); draw(0); }, start(startAt){ KaroState.startAt=(+startAt)|| (audioCtx? audioCtx.currentTime:0); cancelAnimationFrame(KaroState.raf||0); KaroState.raf=requestAnimationFrame(loop); }, stop(){ cancelAnimationFrame(KaroState.raf||0); KaroState.raf=0; } };
})();

//=====NEW: Whole-page fullscreen toggle=====
(function(){
const btn=document.getElementById('btnPageFS');
if(!btn) return;
const docEl=document.documentElement;

function isFS(){ return !!document.fullscreenElement; }

async function enterFS(){
try { await docEl.requestFullscreen(); }
catch(err){ const anyEl=docEl; if(anyEl && anyEl.webkitRequestFullscreen){ anyEl.webkitRequestFullscreen(); } else { try{ log('Fullscreen request failed: '+(err?.message||err)); }catch(_){} } }
}
async function exitFS(){
try { await document.exitFullscreen(); }
catch(err){ const anyDoc=document; if(anyDoc && anyDoc.webkitExitFullscreen){ anyDoc.webkitExitFullscreen(); } else { try{ log('Exit fullscreen failed: '+(err?.message||err)); }catch(_){} } }
}
async function toggleFS(){ if(isFS()) await exitFS(); else await enterFS(); syncUI(); }
function syncUI(){ const active=isFS(); btn.textContent=active? '‚§¢' : '‚õ∂'; btn.setAttribute('aria-pressed', active? 'true':'false'); btn.title=active? 'Exit full screen' : 'Full screen'; }

btn.addEventListener('click', toggleFS);
document.addEventListener('fullscreenchange', syncUI);
document.addEventListener('webkitfullscreenchange', syncUI);

const viz=document.getElementById('vizWrap');
if(viz) viz.addEventListener('dblclick', toggleFS, { passive:true });

document.addEventListener('keydown', async (e)=>{
if(e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase()==='f'){
e.preventDefault();
await toggleFS();
}
});

syncUI();
})();

// (Guarded) density & fit
try { applyDensity?.(settings?.ui?.density); } catch(_) {}
try { autoFit16?.(); } catch(_) {}


// === APPEND: Safe next-line sizing via ResizeObserver (no lifecycle changes) ===
(function(){
function updateNextSize(){
try{
const curr = document.getElementById('karoCurr');
const win  = document.getElementById('winKaro');
if(!curr || !win) return;
const st = window.getComputedStyle(curr);
const currPx = parseFloat(st.fontSize || '0');
if(currPx > 0){
const nextPx = Math.max(10, Math.round(currPx * 0.5));
win.style.setProperty('--next-size', nextPx + 'px');
}
}catch(_){ /* noop */ }
}

function initObserver(){
const curr = document.getElementById('karoCurr');
if(!curr || typeof ResizeObserver === 'undefined'){ updateNextSize(); return; }
try{
const ro = new ResizeObserver(()=>updateNextSize());
ro.observe(curr);
}catch(_){ updateNextSize(); }
}

if(document.readyState==='loading'){
document.addEventListener('DOMContentLoaded', initObserver, { once:true });
} else {
initObserver();
}
window.addEventListener('resize', updateNextSize, { passive:true });
})();





// === APPEND: Karaoke BIG start countdown (dynamic to first highlight, once per song) ===
(function(){
const ROW_ID   = 'karoStartRowDynamic';
const BIG_ID   = 'karoStartBigDynamic';
const BARS_ID  = 'karoStartBarsDynamic';
const SEG_CLASS= 'karoStartSegDynamic';
const SEGMENTS = 6;

let raf = 0;
let didShow = false;
let endTime = 0;
let startStamp = 0;

function buildRow(){
if(document.getElementById(ROW_ID)) return;
const body = document.querySelector('#winKaro .winBody');
const curr = document.getElementById('karoCurr');
if(!body) return;
const row = document.createElement('div');
row.id = ROW_ID;
row.style.display = 'block';
row.style.textAlign = 'center';
row.style.margin = '4px 0 8px';
row.style.position = 'relative';

const big = document.createElement('div');
big.id = BIG_ID;
big.style.fontWeight = '800';
big.style.fontSize = 'clamp(24px, 6.8vw, 72px)';
big.style.lineHeight = '1.0';
big.style.color = 'var(--accent)';
big.style.textShadow = '0 0 14px rgba(0,179,255,0.65), 0 0 28px rgba(0,179,255,0.35)';
big.textContent = '';

const bars = document.createElement('div');
bars.id = BARS_ID;
bars.style.display = 'flex';
bars.style.gap = '6px';
bars.style.justifyContent = 'center';
bars.style.alignItems = 'flex-end';
bars.style.height = '28px';
bars.style.marginTop = '6px';

for(let i=0;i<SEGMENTS;i++){
const seg=document.createElement('div');
seg.className=SEG_CLASS;
const h=10 + Math.round((i+1) * (18/SEGMENTS));
seg.style.width='8px';
seg.style.height=h + 'px';
seg.style.borderRadius='3px';
seg.style.background='var(--accent)';
seg.style.boxShadow='0 0 8px rgba(0,179,255,0.5)';
seg.style.opacity='1.0';
bars.appendChild(seg);
}

const brand=document.createElement('div');
brand.className='karoStartBrand';
brand.textContent='KaraokeHD¬©';
brand.style.marginTop='4px';
brand.style.fontSize='15px';
brand.style.color='#000000FF';
brand.style.letterSpacing='0.02em';
brand.style.opacity='0.85';

row.appendChild(big);
row.appendChild(bars);
row.appendChild(brand);
if(curr && curr.parentNode){ curr.parentNode.insertBefore(row, curr); }
else { body.insertBefore(row, body.firstChild); }
}

function removeRow(){
cancelAnimationFrame(raf||0); raf=0;
const row=document.getElementById(ROW_ID);
if(row) row.remove();
}

function updateBars(delta){
const list=document.querySelectorAll('#'+BARS_ID+' .'+SEG_CLASS);
if(!list || !list.length) return;
const span=Math.max(0.001, endTime - startStamp);
const pct=Math.max(0, Math.min(1, delta / span));
const left=Math.ceil(pct * SEGMENTS);
for(let i=0;i<list.length;i++){
list[i].style.opacity=(i < left) ? '1.0' : '0.25';
}
}

function loop(){
const now=(audioCtx ? audioCtx.currentTime : 0);
const delta=endTime - now;
if(delta <=0){ removeRow(); return; }
const big=document.getElementById(BIG_ID);
if(big) big.textContent=Math.max(0, Math.ceil(delta)).toString();
updateBars(delta);
raf=requestAnimationFrame(loop);
}

function isWordHighlightable(w){
if(!w) return false;
const s=String(w.w || '').trim();
if(!s) return false;
if(s==='\u2420' || s==='‚ê†') return false;
  if(/^<-{3}karaokeHD-{3}>$/.test(s)) return false;
return true;
}
function getFirstHighlightSec(){
try{
const lines = (KaroState && Array.isArray(KaroState.linesPrepared)) ? KaroState.linesPrepared : [];
for(let i=0;i<lines.length;i++){
const L=lines[i] || {};
if(/^<---karaokeHD--->$/.test(String(L.text||''))) continue;
const words = Array.isArray(L.words) ? L.words : [];
for(let j=0;j<words.length;j++){
const w=words[j];
const t=(w && typeof w.t==='number') ? w.t : NaN;
if(isFinite(t) && t> 0.001 && isWordHighlightable(w)) return t;
}
}
}catch(_){ }
return NaN;
}

const origRebuild = window.Karo && window.Karo.rebuild;
const origStart   = window.Karo && window.Karo.start;
const origStop    = window.Karo && window.Karo.stop;
if(window.Karo){
window.Karo.rebuild = function(){
didShow = false;
removeRow();
if(origRebuild) origRebuild.call(window.Karo);
};
window.Karo.start = function(startAt){
if(origStart) origStart.call(window.Karo, startAt);
try{
if(!didShow){
const base = (typeof lyrics.startAt === 'number') ? lyrics.startAt : (audioCtx ? audioCtx.currentTime : 0);
const hSec = getFirstHighlightSec();
if(!isFinite(hSec) || hSec <= 0.05){
didShow = true;
return;
}
buildRow();
startStamp = (audioCtx ? audioCtx.currentTime : 0);
endTime = base + hSec;
cancelAnimationFrame(raf||0);
raf = requestAnimationFrame(loop);
didShow = true;
}
}catch(_){ }
};
window.Karo.stop = function(){
removeRow();
if(origStop) origStop.call(window.Karo);
};
}
})();

// ===== NEW: Consolidated Countdown Manager (replaces both countdown IIFEs) =====
(function(){
// Distinct IDs for two chips
const IDS = {
left:  'karoCountdownLeft',
right: 'karoCountdownRight'
};
let raf = 0;

// Safe guards for globals to avoid early runtime errors
try { typeof applyDensity === 'function' && applyDensity(settings?.ui?.density); } catch(_) {}
try { typeof autoFit16 === 'function' && autoFit16(); } catch(_) {}
if (typeof window.zCounter !== 'number') window.zCounter = 0;

function addChipLeft(){
if(document.getElementById(IDS.left)) return;
const win  = document.getElementById('winKaro');
const body = win && win.querySelector('.winBody');
if(!body) return;

const chip = document.createElement('span');
chip.id = IDS.left;
chip.className = 'chip';
chip.title = 'Seconds until next karaoke line starts';
chip.textContent = '‚è± Next in: --';
chip.style.position = 'absolute';
chip.style.top = '8px';
chip.style.left = '8px';
chip.style.zIndex = '2';
chip.style.pointerEvents = 'none';
chip.setAttribute('aria-hidden', 'true');
try { body.style.position = body.style.position || 'relative'; }catch(_){}
body.appendChild(chip);
}



function computeDelta(nowRel){
const lines = (function(){
try{ return KaroState.linesPrepared || []; }catch(_){ return []; }
})();
if(!lines.length) return NaN;

let li = -1;
for(let i=0;i<lines.length;i++){
const L=lines[i];
if(L.main <=nowRel && nowRel < L.end){ li=i; break; }
if(L.main> nowRel) break;
}

const nextMain =
(li >= 0 && li+1 < lines.length) ? (lines[li+1].main ?? NaN)
: (li < 0 && lines.length ? (lines[0].main ?? NaN) : NaN);

const delta = (isFinite(nextMain) ? (nextMain - nowRel) : NaN);
return (isFinite(delta) && delta >= 0) ? delta : NaN;
}

function updateChip(id, delta){
const chip = document.getElementById(id);
if(!chip) return;
if(!isFinite(delta)){
chip.textContent = '‚è± Next in: --';
chip.style.color = '#9fbad1';
chip.style.display = '';
return;
}
chip.textContent = '‚è± Next in: ' + delta.toFixed(2) + 's';
chip.style.color = (delta < 0.20) ? '#f31260' : (delta < 0.50 ? '#f5a524' : '#9fbad1');
}

function loop(){
const nowRel = (audioCtx ? audioCtx.currentTime : 0) - (KaroState?.startAt || 0);
const delta  = computeDelta(nowRel);
updateChip(IDS.left,  delta);

raf = requestAnimationFrame(loop);
}

const origRebuild = window.Karo && window.Karo.rebuild;
const origStart   = window.Karo && window.Karo.start;
const origStop    = window.Karo && window.Karo.stop;

if(window.Karo){
window.Karo.rebuild = function(){
if(typeof origRebuild === 'function') origRebuild.call(window.Karo);
try {
addChipLeft();
updateChip(IDS.left,  NaN);

} catch(_){}
};
window.Karo.start = function(startAt){
if(typeof origStart === 'function') origStart.call(window.Karo, startAt);
try { addChipLeft(); } catch(_){}
cancelAnimationFrame(raf || 0);
raf = requestAnimationFrame(loop);
};
window.Karo.stop = function(){
cancelAnimationFrame(raf || 0); raf = 0;
if(typeof origStop === 'function') origStop.call(window.Karo);
};
}
})();


(function(){
function centerKaroWindow(){
const w = document.getElementById('winKaro');
if(!w) return;
// Make sure it's visible so we can measure size accurately
const prevDisplay=w.style.display;
w.style.display='block';
w.style.zIndex=(++zCounter).toString();

// Measure after layout paints
requestAnimationFrame(()=> {
try{
const vw = window.innerWidth;
const vh = window.innerHeight;
const rect = w.getBoundingClientRect();
const width  = rect.width  || w.offsetWidth || 680; // fallback
const height = rect.height || w.offsetHeight || 320; // fallback

// Center, with a small safe padding from edges
const PAD = 8;
const left = Math.max(PAD, Math.round((vw - width)  / 2));
const top  = Math.max(PAD, Math.round((vh - height) / 2));

w.style.left = left + 'px';
w.style.top  = top  + 'px';

// Persist to localStorage
settings.windows = settings.windows || {};
settings.windows['winKaro'] = settings.windows['winKaro'] || {};
settings.windows['winKaro'].left  = w.style.left;
settings.windows['winKaro'].top   = w.style.top;
settings.windows['winKaro'].width = w.style.width;   // keep whatever the user had
settings.windows['winKaro'].display = 'block';       // ensure visible
persistSettings();

try{ log('Karaoke window centered'); }catch(_){}
}catch(e){
try{ log('Center failed: ' + (e.message || e)); }catch(_){}
}
});


// if(prevDisplay==='none') w.style.display = 'block';
}

const btn = document.getElementById('karoResetPos');
if(btn) btn.addEventListener('click', centerKaroWindow);

})();

</script>



<script>
(() => {
const $ = (sel) => document.querySelector(sel);

// ---------- Apply to karoCurr/karoNext ----------
function applyKaraokeFont(familyName) {
document.documentElement.style.setProperty('--karaokeFont', `"${familyName}"`);
['karoCurr', 'karoNext'].forEach(id => {
const el = document.getElementById(id);
if (el) el.style.fontFamily = `"${familyName}"`;
});
localStorage.setItem('karaoke.font.family',
familyName);
// Preload to reduce FOIT/FOUT
document.fonts.load(`16px "${familyName}"`).catch(()=> {});
}

// Restore on load
const saved = localStorage.getItem('karaoke.font.family');
if (saved) applyKaraokeFont(saved);

// ---------- Upload (no server): FontFace + blob URL ----------
async function useUploadedFont(file) {
if (!file) {
alert('Select a font file first.'); return;
}
const family = file.name.replace(/\.(ttf|otf|woff2?|)$/i, '');
const blobUrl = URL.createObjectURL(file);
const ff = new FontFace(family, `url(${blobUrl})`);
await ff.load(); // CSS Font Loading API
document.fonts.add(ff); // CSS Font Loading API

// Update picker
const picker = $('#ks-font-family');
if (picker) {
const opt = document.createElement('option');
opt.value = family;
opt.textContent = `${family} (uploaded)`;
picker.insertBefore(opt, picker.firstChild);
picker.value = family;
}
applyKaraokeFont(family);
// Keep blob URL alive for this session
sessionStorage.setItem('karaoke.font.upload.sessionUrl', blobUrl);
}

// ---------- Optional persistence with IndexedDB ----------
const IDB_NAME = 'karaoke-fonts';
const IDB_STORE = 'fonts';
let db;
function openDB() {
return new Promise((resolve, reject) => {
const req = indexedDB.open(IDB_NAME, 1);
req.onupgradeneeded = (e) => {
const d = e.target.result;
if (!d.objectStoreNames.contains(IDB_STORE)) {
d.createObjectStore(IDB_STORE, {
keyPath: 'family'
});
}
};
req.onsuccess = (e) => {
db = e.target.result; resolve(db);
};
req.onerror = (e) => reject(e.target.error);
});
}

async function saveFontToIDB(file) {
if (!file) {
alert('Select a font file first.'); return;
}
const family = file.name.replace(/\.(ttf|otf|woff2?|)$/i, '');
await openDB();
return new Promise((resolve, reject) => {
const tx = db.transaction(IDB_STORE, 'readwrite');
const store = tx.objectStore(IDB_STORE);
const putReq = store.put({
family, blob: file, label: `${family} (local)`
});
tx.oncomplete = () => resolve(family);
tx.onerror = (e) => reject(e.target.error);
});
}

async function loadFontsFromIDB() {
await openDB();
return new Promise((resolve, reject) => {
const tx = db.transaction(IDB_STORE, 'readonly');
const store = tx.objectStore(IDB_STORE);
const req = store.getAll();
req.onsuccess = async (e) => {
const fonts = e.target.result || [];
for (const f of fonts) {
// Create a blob URL and register
const url = URL.createObjectURL(f.blob);
const ff = new FontFace(f.family, `url(${url})`);
try {
await ff.load();
document.fonts.add(ff);
// Add to picker
const picker = $('#ks-font-family');
if (picker) {
const opt = document.createElement('option');
opt.value = f.family;
opt.textContent = f.label || `${f.family} (local)`;
picker.appendChild(opt);
}
} catch (err) {
console.warn('Failed to load IDB font:', f.family, err);
}
}
resolve(fonts.length);
};
req.onerror = (e) => reject(e.target.error);
});
}

// Load any persisted fonts on startup
loadFontsFromIDB().then((count) => {
const status = $('#ks-device-fonts-status');
if (status && count) status.textContent = `Loaded ${count} saved fonts (local).`;
}).catch(()=> {});

// ---------- Device font listing (if supported) ----------
async function scanDeviceFonts() {
const status = $('#ks-device-fonts-status');
// Requires secure context (HTTPS or localhost) + user permission; not on file://
if (!('queryLocalFonts' in window)) {
status.textContent = 'Device font listing not supported in this context.';
return;
}
try {
const fonts = await window.queryLocalFonts(); // Permission prompt on first call
const picker = $('#ks-font-family');
const seen = new Set();
let added = 0;
fonts.forEach(f => {
const family = f.fullName || f.family || f.postscriptName || 'Unknown';
if (seen.has(family)) return;
seen.add(family); added++;
const opt = document.createElement('option');
opt.value = family; opt.textContent = `${family} (device)`;
picker.appendChild(opt);
});
status.textContent = `Found ${added} device fonts.`;
} catch (err) {
status.textContent = `Denied or unavailable (${err.name}).`;
}
}

// ---------- Manual device font test (fallback) ----------
// Tries to detect if a typed font name is present by comparing canvas text metrics.
function isFontAvailable(fontName) {
const testText = 'mmmmmmmmmmWWWWWWWWW12345';
const size = 64;
const canvas = document.createElement('canvas');
canvas.width = 1000; canvas.height = 200;
const ctx = canvas.getContext('2d');
// Measure with a generic fallback
ctx.font = `${size}px sans-serif`;
const baseline = ctx.measureText(testText).width;
// Measure with requested font (if not present, width is usually identical)
ctx.font = `${size}px "${fontName}", sans-serif`;
const withFont = ctx.measureText(testText).width;
return Math.abs(withFont - baseline) > 0.5; // heuristic threshold
}

function testAndApplyManualFont() {
const name = $('#ks-font-manual-name').value.trim();
if (!name) return;
const status = $('#ks-device-fonts-status');
if (isFontAvailable(name)) {
// Try to apply directly; optional: also define @font-face local() rule
applyKaraokeFont(name);
status.textContent = `Applied device font: ${name}`;
} else {
status.textContent = `Font not detected: ${name}. Try uploading the TTF.`;
}
}

// ---------- Wire up ----------
const picker = $('#ks-font-family');
if (picker) picker.addEventListener('change', (e) => applyKaraokeFont(e.target.value));

const uploadBtn = $('#ks-font-use-upload');
const idbBtn = $('#ks-font-save-idb');
const fileInput = $('#ks-font-file');
const scanBtn = $('#ks-scan-device-fonts');
const testBtn = $('#ks-test-manual-font');

if (uploadBtn) uploadBtn.addEventListener('click', () => useUploadedFont(fileInput.files?.[0]));
if (idbBtn) idbBtn.addEventListener('click', async () => {
try {
const fam = await saveFontToIDB(fileInput.files?.[0]);
// Immediately load from IDB so the font becomes active
await loadFontsFromIDB();
applyKaraokeFont(fam);
const picker = $('#ks-font-family');
if (picker) picker.value = fam;
} catch (e) {
alert('Save failed: ' + e.message);
}
});
if (scanBtn) scanBtn.addEventListener('click', () => scanDeviceFonts());
if (testBtn) testBtn.addEventListener('click', () => testAndApplyManualFont());
})();
</script>

<script>
(() => {
const $ = (sel) => document.querySelector(sel);

// ---- Where to apply the chosen font (your karaoke lines)
function applyKaraokeFont(familyOrStack) {
// Use CSS var so your CSS rule `#karoCurr, #karoNext { font-family: var(--karaokeFont); }` picks it up.
document.documentElement.style.setProperty('--karaokeFont', familyOrStack);

// Inline override (wins if other rules compete)
['karoCurr',
'karoNext'].forEach(id => {
const el = document.getElementById(id);
if (el) el.style.fontFamily = familyOrStack;
});

localStorage.setItem('karaoke.font.choice',
familyOrStack);
// Preload to reduce FOIT/FOUT
// Try to load the first quoted name (or the first unquoted token) for better preloading.
const first = (familyOrStack.match(/"([^"]+)"/) || familyOrStack.split(',')[0] || '').toString().replace(/(^"|"$)/g,
'');
if (first) document.fonts.load(`16px ${first}`).catch(()=> {});
}

// ---- Your preset font lists
// ---- Expanded preset font lists
const PRESETS = {
  // ===== Default serif stack =====
  'Defaults': [
    'Times New Roman',
    'Times',
    'serif'
  ],

  // ===== Platform-specific UI stacks =====
  'Windows': [
    'Segoe UI Variable Text',
    'Segoe UI Variable Display',
    'Segoe UI Variable Small',
    'Segoe UI',
    'Bahnschrift'
  ],
  'Android': [
    'Roboto',
    'Noto Sans',
    'Droid Sans',
    'Roboto Flex'
  ],
  'Linux': [
    'Ubuntu',
    'Cantarell',
    'Noto Sans',
    'DejaVu Sans',
    'FreeSans'
  ],
  'macOS': [
    'SF Pro Text',
    'SF Pro Display',
    'Helvetica Neue',
    'Helvetica',
    'Arial'
  ],
  'iOS': [
    '-apple-system',
    'SF Pro Text',
    'SF Pro Display',
    'Helvetica Neue',
    'Arial'
  ],
  'ChromeOS': [
    'Roboto',
    'Noto Sans',
    'Arial'
  ],

  // ===== Document serif stacks =====
  'Serif (Classic)': [
    'Times New Roman',
    'Times',
    'Georgia',
    'serif'
  ],
  'Serif (Readable)': [
    'Georgia',
    'Times New Roman',
    'Times',
    'serif'
  ],

  // ===== Document sans-serif stacks =====
  'Sans (Web-safe)': [
    'Arial',
    'Helvetica',
    'system-ui',
    'sans-serif'
  ],
  'Sans (Humanist)': [
    'Segoe UI',
    'Roboto',
    'Noto Sans',
    'Ubuntu',
    'Cantarell',
    'sans-serif'
  ],

  // ===== Office stacks =====
  'Office (Sans)': [
    'Calibri',
    'Arial',
    'Helvetica',
    'sans-serif'
  ],
  'Office (Serif)': [
    'Cambria',
    'Times New Roman',
    'Times',
    'serif'
  ],

  // ===== Monospace stacks =====
  'Monospace (Dev)': [
    'Consolas',
    'SF Mono',
    'Menlo',
    'DejaVu Sans Mono',
    'Monaco',
    'Courier New',
    'monospace'
  ],

  // ===== CJK stacks =====
  'CJK (Simplified Chinese)': [
    'Microsoft YaHei',
    'Noto Sans SC',
    'PingFang SC',
    'WenQuanYi Zen Hei',
    'sans-serif'
  ],
  'CJK (Traditional Chinese)': [
    'Microsoft JhengHei',
    'Noto Sans TC',
    'PingFang TC',
    'Heiti TC',
    'sans-serif'
  ],
  'CJK (Japanese)': [
    'Meiryo',
    'Yu Gothic',
    'Hiragino Kaku Gothic ProN',
    'Noto Sans JP',
    'sans-serif'
  ],
  'CJK (Korean)': [
    'Malgun Gothic',
    'Apple SD Gothic Neo',
    'Noto Sans KR',
    'sans-serif'
  ],

  // ===== RTL / Script-specific stacks =====
  'Arabic': [
    'Noto Sans Arabic',
    'Segoe UI',
    'Tahoma',
    'sans-serif'
  ],
  'Hebrew': [
    'Noto Sans Hebrew',
    'Arial',
    'Tahoma',
    'sans-serif'
  ],

  // ===== Cross-platform stacks =====
  'Cross-platform': [
    'system-ui',
    '-apple-system',
    'Segoe UI',
    'Roboto',
    'Noto Sans',
    'Ubuntu',
    'Cantarell',
    'Arial',
    'sans-serif'
  ],

  // ===== Karaoke fonts =====
  'Karaoke': [
    'LT Karaoke',             // Designed for karaoke screens
    'The Frontman',           // Bold display font
    'Black Elite',            // Condensed, legible
    'Diskopia',               // Stylized free font
    'Karaoke Superstar BV',   // Decorative karaoke font
    'Apercu',                 // Premium clean display
    'Gotham',                 // Modern professional
    'Avenir Next',            // Elegant sans-serif
    'Helvetica Now'           // Crisp UI font
  ],

  // ===== Experimental =====
  'Experimental': [
    'Inter',
    'IBM Plex Sans',
    'Roboto Flex',
    'SF Pro Text',
    'SF Pro Display'
  ]
};

// Composite stack string (cross‚ÄëOS ‚Äúnative‚Äù look)
const FAMILY_MAP = {
'system-ui stack': 'system-ui, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial, sans-serif'
};

// ---- Populate #ks-font-family with optgroups
function addPresetOptions() {
const picker = $('#ks-font-family');
if (!picker) return;

// Keep existing options (from uploads or device scan), then append our groups
Object.entries(PRESETS).forEach(([groupLabel, fonts]) => {
const og = document.createElement('optgroup');
og.label = groupLabel;
fonts.forEach(name => {
const opt = document.createElement('option');
opt.value = (name in FAMILY_MAP) ? FAMILY_MAP[name]: `"${name}"`; // quote real names; stacks are full lists
opt.textContent = name;
og.appendChild(opt);
});
picker.appendChild(og);
});

// Restore last chosen font (if any)
const saved = localStorage.getItem('karaoke.font.choice');
if (saved) {
// If saved value matches one of the new option values, select it.
const match = Array.from(picker.options).find(o => o.value === saved);
if (match) picker.value = saved,
applyKaraokeFont(saved);
}
}

// ---- Wire change handler
function wirePicker() {
const picker = $('#ks-font-family');
if (!picker) return;
picker.addEventListener('change', (e) => {
const val = e.target.value;
applyKaraokeFont(val);
});
}

// ---- Boot
addPresetOptions();
wirePicker();

// Optional: if you have a ‚ÄúFont source‚Äù select (#ks-font-source), refresh list when changing.
const src = $('#ks-font-source');
if (src) src.addEventListener('change', () => {
// Do nothing special; presets remain in the list alongside uploads/device fonts.
// If you prefer to hide presets for certain sources, filter here.
});
})();
</script>

<script>
// Rebuild the Lyric Source dropdown options based on current song/meta events.
// - Keeps current selection if still valid; otherwise falls back to 'auto'.
// - Optionally disables items with zero events in the current song.
function rebuildLyricSourceOptions(metaEvs) {
  const srcSel = document.getElementById('lySrc');
  if (!srcSel) return;

  // Count types in current song
  const counts = { 0x05: 0, 0x01: 0, 0x03: 0 };
  for (const e of (metaEvs || [])) {
    if (!e || e.kind !== 'meta') continue;
    const t = e.type | 0;
    if (t === 0x05 || t === 0x01 || t === 0x03) counts[t]++;
  }

  // Preserve current selection if possible
  const currentVal = (settings?.lyrics?.source) || 'auto';

  // Clear existing options
  srcSel.innerHTML = '';

  // Helper to add an <option>
  function addOpt(value, label, enabled = true) {
    const opt = document.createElement('option');
    opt.value = value;
    opt.textContent = label;
    if (!enabled) {
      opt.disabled = true;
      opt.textContent = `${label} (none)`;
    }
    srcSel.appendChild(opt);
  }

  // Always offer AUTO single-source
  addOpt('auto', 'Auto (single-source)');

  // Fixed single-source options
  addOpt('05', `Lyric 0x05${counts[0x05] ? ` (${counts[0x05]})` : ''}`, counts[0x05] > 0);
  addOpt('01', `Text 0x01${counts[0x01] ? ` (${counts[0x01]})` : ''}`, counts[0x01] > 0);
  addOpt('03', `Track Name 0x03${counts[0x03] ? ` (${counts[0x03]})` : ''}`, counts[0x03] > 0);

  // Restore selection if still valid; else fall back to 'auto'
  const validValues = ['auto', '05', '01', '03'];
  const resolved = validValues.includes(currentVal) ? currentVal : 'auto';
  srcSel.value = resolved;

  // Mirror into settings + runtime for consistency (optional, keeps state clean)
  settings.lyrics.source = resolved;
  lyrics.source = resolved;
  try { persistSettings(); } catch(_) {}
}
</script>



¬†<script>
(function () {
  const win = document.getElementById('winKaro');
  const body = win?.querySelector('.winBody');
  const btnFS = win?.querySelector('#btnKaroFS');
  if (!win || !body) return;

  /* ========= Simple in-window settings button + mini panel (APPENDED TO WINDOW) ========= */
  const simpleBtn = document.createElement('button');
  simpleBtn.className = 'karoSimpleBtn';
  simpleBtn.title = 'Settings';
  simpleBtn.textContent = '‚öô';
  win.appendChild(simpleBtn);

  const miniPanel = document.createElement('div');
  miniPanel.className = 'karoMiniPanel';
  miniPanel.innerHTML = `
    <div class="row">
      <label><input type="checkbox" id="mpShowControls"> Show Controls</label>
    </div>
    <div class="row">
      <label><input type="checkbox" id="mpBgEnabled"> Video Background</label>
    </div>
  `;
  win.appendChild(miniPanel);

  const mpShowControls = miniPanel.querySelector('#mpShowControls');
  const mpBgEnabled    = miniPanel.querySelector('#mpBgEnabled');

  let autoHideTimer = null;
  function showPanel() {
    miniPanel.style.display = 'block';
    resetAutoHide();
  }
  function hidePanel() {
    miniPanel.style.display = 'none';
    clearTimeout(autoHideTimer);
  }
  function resetAutoHide() {
    clearTimeout(autoHideTimer);
    autoHideTimer = setTimeout(() => {
      miniPanel.style.display = 'none';
    }, 4000);
  }
  simpleBtn.addEventListener('click', () => {
    if (miniPanel.style.display === 'block') hidePanel();
    else showPanel();
  });
  miniPanel.addEventListener('mousemove', resetAutoHide);
  miniPanel.addEventListener('touchmove', resetAutoHide, { passive: true });

  /* ========= Video background & overlay (APPENDED TO WINDOW) ========= */
  let video = null, overlay = null;

  function ensureVideo() {
    if (video) return;
    video = document.createElement('video');
    video.id = 'karoBgVideo';
    video.className = 'karoBgVideo';
    video.autoplay = true;
    video.loop = false;
    video.muted = true;
    video.playsInline = true;    // mobile-safe autoplay
    video.preload = 'auto';
    win.appendChild(video);      // anchor to whole window for full coverage

    overlay = document.createElement('div');
    overlay.className = 'karoOverlay';
    win.appendChild(overlay);

    // Auto advance background when a video ends
    video.addEventListener('ended', next);

    // Status updates
    video.addEventListener('play', () => {
      if (statusEl) {
        statusEl.textContent = pl.length
          ? `Playing ${idx+1}/${pl.length}: ${pl[idx]?.name || ''}`
          : 'Playing';
      }
    });
    video.addEventListener('pause', () => { if (statusEl) statusEl.textContent = 'Paused'; });
  }

  /* ========= Playlist controls (APPENDED TO WINDOW to avoid .winBody clipping) ========= */
  let plWrap = null;
  let input = null, listEl = null, statusEl = null;
  let btnPrev = null, btnNext = null, btnClear = null, chkLoop = null, chkShuffle = null;

  function ensureControls() {
    if (plWrap) return;
    plWrap = document.createElement('div');
    plWrap.className = 'karoPL hidden';
    plWrap.innerHTML = `
      <div class="karoPLRow">
        <label for="karoVideoFiles">Browse:</label>
        <input type="file" id="karoVideoFiles" accept="video/*" multiple>
        <button id="plPrev" class="btn">Prev</button>
        <button id="plNext" class="btn">Next</button>
        <label class="toggle"><input type="checkbox" id="plLoop"> Loop</label>
        <label class="toggle"><input type="checkbox" id="plShuffle"> Shuffle</label>
        <button id="plClear" class="btn">Clear</button>
      </div>
      <ol id="karoVideoPlList" class="karoPLList" aria-live="polite" aria-label="Playlist"></ol>
      <div id="plStatus" class="karoPLStatus" role="status" aria-live="polite"></div>
    `;
    win.appendChild(plWrap); // append to window (not .winBody)

    input      = plWrap.querySelector('#karoVideoFiles');
    listEl     = plWrap.querySelector('#karoVideoPlList');
    statusEl   = plWrap.querySelector('#plStatus');
    btnPrev    = plWrap.querySelector('#plPrev');
    btnNext    = plWrap.querySelector('#plNext');
    btnClear   = plWrap.querySelector('#plClear');
    chkLoop    = plWrap.querySelector('#plLoop');
    chkShuffle = plWrap.querySelector('#plShuffle');

    input.addEventListener('change', onFilesSelected);
    btnNext.addEventListener('click', next);
    btnPrev.addEventListener('click', prev);
    btnClear.addEventListener('click', clearPlaylist);

    // Keep panel alive while user is interacting with the playlist
    ['mousemove', 'mouseover', 'wheel', 'touchmove', 'click'].forEach(evt => {
      plWrap.addEventListener(evt, () => { resetAutoHide(); }, { passive: true });
    });

    renderList();
  }

  function setControlsVisible(visible) {
    ensureControls();
    // Toggle class and inline style to defeat any stale CSS
    plWrap.classList.toggle('hidden', !visible);
    plWrap.style.display = visible ? '' : 'none';
    // Re-append to window to bump stacking order (in case other nodes were added later)
    win.appendChild(plWrap);
    mpShowControls.checked = visible;
    resetAutoHide();
  }

  /* ========= Background video toggle (respects your static color) ========= */
  function setBackgroundEnabled(enabled) {
    if (enabled) {
      win.classList.add('karoHasBg');  // CSS applies only when BG is ON
      ensureVideo();
      video.style.display = '';
      overlay.style.display = '';
      // If a playlist item is selected, start it
      if (idx >= 0 && pl[idx]) { fadeTo(pl[idx].url); }
    } else {
      win.classList.remove('karoHasBg'); // your static color shows now
      if (video) {
        video.pause();
        video.removeAttribute('src');
        video.load();
        video.style.display = 'none';
      }
      if (overlay) overlay.style.display = 'none';
    }
    // Re-append to bump stacking order above video
    win.appendChild(simpleBtn);
    win.appendChild(miniPanel);
    mpBgEnabled.checked = enabled;
    resetAutoHide();
  }

  /* ========= Wire the checkboxes robustly ========= */
  mpShowControls.addEventListener('change', (e) => {
    setControlsVisible(e.target.checked);
  });
  mpBgEnabled.addEventListener('change', (e) => {
    setBackgroundEnabled(e.target.checked);
  });

  /* ========= Playlist logic ========= */
  let pl = [];      // [{ name, url, duration }]
  let idx = -1;
  let revoked = [];
  const fadeMs = 250;

  const fmt = s => isFinite(s) ? `${Math.floor(s/60)}:${String(Math.floor(s%60)).padStart(2,'0')}` : '--:--';

  async function fadeTo(srcUrl) {
    if (!video) return;
    video.style.opacity = '0';
    await new Promise(r => setTimeout(r, fadeMs));
    video.src = srcUrl;
    try { video.currentTime = 0; } catch {}
    video.play().catch(() => {});
    video.style.opacity = '1';
  }

  function playIndex(i) {
    if (i < 0 || i >= pl.length) return;
    idx = i;
    if (win.classList.contains('karoHasBg')) fadeTo(pl[i].url);
    renderList();
  }

  function next() {
    if (!pl.length) return;
    if (chkShuffle?.checked) {
      let n;
      if (pl.length === 1) n = 0;
      else { do { n = Math.floor(Math.random() * pl.length); } while (n === idx); }
      playIndex(n);
      return;
    }
    const n = idx + 1;
    if (n < pl.length) playIndex(n);
    else if (chkLoop?.checked) playIndex(0);
  }

  function prev() {
    if (!pl.length) return;
    const p = idx - 1;
    if (p >= 0) playIndex(p);
    else if (chkLoop?.checked) playIndex(pl.length - 1);
  }

  async function onFilesSelected() {
    const files = Array.from(this.files || []);
    if (!files.length) return;

    for (const f of files) {
      const url = URL.createObjectURL(f);
      revoked.push(url);
      const item = { name: f.name, url, duration: NaN };

      // Probe duration via temp video
      const probe = document.createElement('video');
      probe.preload = 'metadata';
      probe.src = url;
      await new Promise((res) => {
        const ok = () => { item.duration = probe.duration; cleanup(); res(); };
        const err = () => { cleanup(); res(); };
        const cleanup = () => {
          probe.removeEventListener('loadedmetadata', ok);
          probe.removeEventListener('error', err);
          probe.src = '';
        };
        probe.addEventListener('loadedmetadata', ok, { once: true });
        probe.addEventListener('error', err, { once: true });
      });

      pl.push(item);
    }

    // Start first item if idle
    if (idx < 0 && pl.length) playIndex(0);
    renderList();
    this.value = ''; // allow re-adding same files

    // Optional: show controls and turn BG ON right after playlist creation
    setControlsVisible(true);
    setBackgroundEnabled(true);

    resetAutoHide();
  }

  function clearPlaylist() {
    if (video) {
      video.pause();
      video.removeAttribute('src');
      video.load();
    }
    idx = -1;
    for (const u of revoked) { try { URL.revokeObjectURL(u); } catch {} }
    revoked = [];
    pl = [];
    renderList();
    resetAutoHide();
  }

  function renderList() {
    if (!listEl) return;
    listEl.innerHTML = '';
    pl.forEach((item, i) => {
      const li = document.createElement('li');
      const idxSpan = document.createElement('span');
      idxSpan.className = 'idx';
      idxSpan.textContent = i + 1;

      const nameSpan = document.createElement('span');
      nameSpan.className = 'name';
      nameSpan.textContent = item.name;

      const durSpan = document.createElement('span');
      durSpan.className = 'dur';
      durSpan.textContent = fmt(item.duration);

      li.append(idxSpan, nameSpan, durSpan);
      if (i === idx) li.classList.add('now');
      li.addEventListener('click', () => playIndex(i));
      listEl.appendChild(li);
    });

    if (statusEl) {
      statusEl.textContent = pl.length
        ? `Items: ${pl.length} ‚Ä¢ ${idx >= 0 ? `Selected ${idx+1}/${pl.length}` : 'Idle'}`
        : 'Playlist empty';
    }
  }

  /* ========= Fullscreen button wire-up (‚õ∂ targets whole window) ========= */
  if (btnFS) {
    btnFS.addEventListener('click', async () => {
      try {
        if (!document.fullscreenElement) {
          await win.requestFullscreen(); // full window; video covers fully
          btnFS.setAttribute('aria-pressed', 'true');
        } else {
          await document.exitFullscreen();
          btnFS.setAttribute('aria-pressed', 'false');
        }
      } catch (e) { console.error('Fullscreen error:', e); }
    });
    document.addEventListener('fullscreenchange', () => {
      const pressed = !!document.fullscreenElement;
      btnFS.setAttribute('aria-pressed', pressed ? 'true' : 'false');
    });
  }

  /* ========= Pause BG when window hidden ========= */
  const observer = new MutationObserver(() => {
    const hidden = getComputedStyle(win).display === 'none' || win.hidden;
    if (hidden && video) video.pause();
  });
  observer.observe(win, { attributes: true, attributeFilter: ['style', 'hidden'] });

  /* ========= Initial state ========= */
  miniPanel.style.display = 'none';
})();
</script>

<script>
(function () {
  if (!('mediaSession' in navigator)) {
    console.warn('Media Session API not supported in this browser.');
    return;
  }

  // ---- Helpers to reach your state ----
  function getVideo() {
    return document.getElementById('karoBgVideo');
  }
  function getState() {
    const pl  = (window.pl && Array.isArray(window.pl)) ? window.pl : [];
    const idx = (typeof window.idx === 'number') ? window.idx : -1;
    return { pl, idx };
  }

  // Build nice metadata for OS UI
  function buildMetadata(item, i, total) {
    const fileName = item?.name || 'Unknown';
    const title = fileName.replace(/\.[a-z0-9]+$/i, '');
    const artist = 'KaraokeHD';           // you can change this
    const album = `Playlist ${i+1}/${total}`;
    const artwork = [];                   // provide URLs if you have covers
    // artwork.push({ src: 'assets/covers/' + title + '.png', sizes: '512x512', type: 'image/png' });

    return new MediaMetadata({ title, artist, album, artwork });
  }

  // Publish/update metadata + state
  function updateMediaSession() {
    const v = getVideo();
    const { pl, idx } = getState();
    if (!pl.length || idx < 0 || idx >= pl.length) return;

    try {
      navigator.mediaSession.metadata = buildMetadata(pl[idx], idx, pl.length);
    } catch (e) {}

    // Playback state hint
    if (v) {
      try {
        navigator.mediaSession.playbackState = v.paused ? 'paused' : 'playing';
        navigator.mediaSession.setPositionState({
          duration: isFinite(v.duration) ? v.duration : 0,
          position: isFinite(v.currentTime) ? v.currentTime : 0,
          playbackRate: v.playbackRate || 1
        });
      } catch (e) {}
    }
  }

  // Wire OS actions to your functions/video
  function wireActionHandlers() {
    const v = getVideo();

    try {
      navigator.mediaSession.setActionHandler('play', async () => {
        try { await v?.play(); } catch (_) {}
        updateMediaSession();
      });
    } catch (_) {}
    try {
      navigator.mediaSession.setActionHandler('pause', () => {
        try { v?.pause(); } catch (_) {}
        updateMediaSession();
      });
    } catch (_) {}
    try {
      navigator.mediaSession.setActionHandler('nexttrack', () => {
        if (typeof window.next === 'function') window.next();
        else if (typeof window.playIndex === 'function') {
          const { pl, idx } = getState();
          if (idx + 1 < pl.length) window.playIndex(idx + 1);
        }
        setTimeout(updateMediaSession, 50);
      });
    } catch (_) {}
    try {
      navigator.mediaSession.setActionHandler('previoustrack', () => {
        if (typeof window.prev === 'function') window.prev();
        else if (typeof window.playIndex === 'function') {
          const { pl, idx } = getState();
          if (idx - 1 >= 0) window.playIndex(idx - 1);
        }
        setTimeout(updateMediaSession, 50);
      });
    } catch (_) {}

    // Optional seek handlers:
    try {
      navigator.mediaSession.setActionHandler('seekto', (details) => {
        if (!v || typeof details.seekTime !== 'number') return;
        v.currentTime = details.seekTime;
        updateMediaSession();
      });
      navigator.mediaSession.setActionHandler('seekforward', () => {
        if (!v) return;
        v.currentTime = Math.min(v.duration || v.currentTime + 10, v.currentTime + 10);
        updateMediaSession();
      });
      navigator.mediaSession.setActionHandler('seekbackward', () => {
        if (!v) return;
        v.currentTime = Math.max(0, v.currentTime - 10);
        updateMediaSession();
      });
    } catch (_) {}
  }

  // Keep metadata fresh when your app changes track
  function attachTrackChangeHooks() {
    if (typeof window.playIndex === 'function' && !window.__ms_wrapped_playIndex) {
      const orig = window.playIndex;
      window.playIndex = function(i) {
        const res = orig.call(this, i);
        setTimeout(updateMediaSession, 50);
        return res;
      };
      window.__ms_wrapped_playIndex = true;
    }
    if (typeof window.next === 'function' && !window.__ms_wrapped_next) {
      const orig = window.next;
      window.next = function() {
        const res = orig.call(this);
        setTimeout(updateMediaSession, 50);
        return res;
      };
      window.__ms_wrapped_next = true;
    }
    if (typeof window.prev === 'function' && !window.__ms_wrapped_prev) {
      const orig = window.prev;
      window.prev = function() {
        const res = orig.call(this);
        setTimeout(updateMediaSession, 50);
        return res;
      };
      window.__ms_wrapped_prev = true;
    }

    // Also update on actual play/pause/time changes
    const v = getVideo();
    if (v && !v.__ms_bound) {
      v.addEventListener('play', updateMediaSession);
      v.addEventListener('pause', updateMediaSession);
      v.addEventListener('timeupdate', () => {
        try {
          navigator.mediaSession.setPositionState({
            duration: isFinite(v.duration) ? v.duration : 0,
            position: isFinite(v.currentTime) ? v.currentTime : 0,
            playbackRate: v.playbackRate || 1
          });
        } catch (e) {}
      });
      v.addEventListener('ended', () => setTimeout(updateMediaSession, 100));
      v.__ms_bound = true;
    }
  }

  wireActionHandlers();
  attachTrackChangeHooks();
  updateMediaSession();

  // If the video element is created later, re-hook automatically
  const target = document.getElementById('winKaro') || document.body;
  const mo = new MutationObserver(() => {
    const v = getVideo();
    if (v && !v.__ms_bound) {
      attachTrackChangeHooks();
      updateMediaSession();
    }
  });
  mo.observe(target, { childList: true, subtree: true });
})();
</script>

<script>
(function () {
  // Find your karaoke window
  const win = document.getElementById('winKaro');
  if (!win) return;

  // Helper: ensure the video element exists (your code may append it lazily)
  function getVideo() {
    return document.getElementById('karoBgVideo');
  }

  // Arm the one-time gesture when the video is present
  function armGestureOnce() {
    // If the video is not yet on the DOM, wait for it
    const v = getVideo();
    if (!v) return;

    async function onTap() {
      const video = getVideo();
      if (!video) return;

      // Unmute + very low ambience volume (requires user gesture)
      video.muted = false;
      video.volume = 0.001;  // 2% ambience; adjust 0.01‚Äì0.03 as you like

      // Try to play (gesture-backed); ignore errors silently
      await video.play().catch(()=>{});

      // If you have Media Session wiring, refresh the OS media state
      if (typeof updateMediaSession === 'function') {
        updateMediaSession();
      }

      // Remove handlers after first successful tap
      win.removeEventListener('click', onTap);
      win.removeEventListener('touchend', onTap);
    }

    // Attach once; any tap/click inside the karaoke window qualifies
    win.addEventListener('click', onTap, { once: true });
    win.addEventListener('touchend', onTap, { once: true, passive: true });
  }

  // Try to arm immediately
  armGestureOnce();

  // If your video is appended later, watch the DOM and arm when it appears
  const mo = new MutationObserver(() => {
    if (getVideo()) {
      armGestureOnce();
      mo.disconnect(); // done; no need to keep watching
    }
  });
  mo.observe(win, { childList: true, subtree: true });
})();
</script>
<script>
// Cleanup any uploaded font blob URL kept in sessionStorage when the page unloads
window.addEventListener('unload', () => {
  try {
    const u = sessionStorage.getItem('karaoke.font.upload.sessionUrl');
    if (u) {
      try { URL.revokeObjectURL(u); } catch(_) {}
      sessionStorage.removeItem('karaoke.font.upload.sessionUrl');
    }
  } catch (_) {}
});
</script>
</body>
</html>
